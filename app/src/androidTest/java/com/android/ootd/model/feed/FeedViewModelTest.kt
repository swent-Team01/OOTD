package com.android.ootd.ui.feed

import androidx.compose.ui.test.junit4.createComposeRule
import com.android.ootd.model.account.Account
import com.android.ootd.model.account.AccountRepositoryFirestore
import com.android.ootd.model.feed.FeedRepositoryFirestore
import com.android.ootd.model.posts.OutfitPost
import com.android.ootd.utils.FirebaseEmulator
import com.android.ootd.utils.FirestoreTest
import com.google.firebase.auth.FirebaseAuth
import junit.framework.TestCase.*
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.runBlocking
import kotlinx.coroutines.tasks.await
import org.junit.Before
import org.junit.Rule
import org.junit.Test

// ACKNOWLEDGEMENT: The following tests were partly generated by AI and verified by human.

/**
 * Connected (emulator-backed) tests for FeedViewModel.
 *
 * These use the Firebase emulator to verify correct Firestore and Auth behavior.
 */
class FeedViewModelFirebaseTest : FirestoreTest() {
  @get:Rule val composeTestRule = createComposeRule()

  private lateinit var viewModel: FeedViewModel
  private lateinit var auth: FirebaseAuth
  private lateinit var accountRepo: AccountRepositoryFirestore
  private lateinit var feedRepo: FeedRepositoryFirestore

  @Before
  override fun setUp() {
    super.setUp()
    auth = FirebaseEmulator.auth
    accountRepo = AccountRepositoryFirestore(FirebaseEmulator.firestore)
    feedRepo = FeedRepositoryFirestore(FirebaseEmulator.firestore)

    runBlocking { auth.signInAnonymously().await() }

    viewModel = FeedViewModel(feedRepo, accountRepo)
  }

  @Test
  fun feedLoadsAccountAndEmptyPostsInitially() = runBlocking {
    val uid = auth.currentUser!!.uid
    val account = Account(uid, uid, "bob", friendUids = emptyList())
    FirebaseEmulator.firestore.collection("accounts").document(uid).set(account).await()

    // Give the auth listener time to pick up the account
    delay(1000)

    // Wait for the account to be loaded by the auth listener
    composeTestRule.waitUntil(timeoutMillis = 5000) {
      viewModel.uiState.value.currentAccount != null
    }

    viewModel.refreshFeedFromFirestore()
    delay(500)

    val state = viewModel.uiState.first()
    assertNotNull(state.currentAccount)
    assertEquals("bob", state.currentAccount?.username)
    assertTrue(state.feedPosts.isEmpty())
  }

  @Test
  fun refreshFeed_populatesPostsFromFriends() = runBlocking {
    val uid = auth.currentUser!!.uid

    val account = Account(uid, uid, "bob", friendUids = listOf(uid))
    FirebaseEmulator.firestore.collection("accounts").document(uid).set(account).await()

    val post =
        OutfitPost(
            postUID = "p1",
            ownerId = uid,
            name = "bob",
            description = "today’s outfit",
            outfitURL = "https://example.com/fake.jpg",
            timestamp = System.currentTimeMillis())
    FirebaseEmulator.firestore.collection("posts").document(post.postUID).set(post).await()

    viewModel.setCurrentAccount(account)
    viewModel.refreshFeedFromFirestore()
    waitUntilFeedLoaded()

    composeTestRule.waitUntil(timeoutMillis = 5000) {
      viewModel.uiState.value.feedPosts.isNotEmpty()
    }

    val state = viewModel.uiState.value
    assertEquals("today’s outfit", state.feedPosts.first().description)
    assertEquals(uid, state.feedPosts.first().ownerId)
  }

  @Test
  fun feedClearsWhenUserLogsOut() = runBlocking {
    val uid = auth.currentUser!!.uid
    FirebaseEmulator.firestore
        .collection("accounts")
        .document(uid)
        .set(Account(uid, uid, "bob"))
        .await()

    delay(500)
    auth.signOut()
    delay(500)

    val state = viewModel.uiState.first()
    assertNull(state.currentAccount)
    assertTrue(state.feedPosts.isEmpty())
  }

  @Test
  fun refresh_setsHasPostedToday_whenUserPostedToday() = runBlocking {
    val uid = auth.currentUser!!.uid
    val account = Account(uid, uid, "bob", friendUids = emptyList())
    FirebaseEmulator.firestore.collection("accounts").document(uid).set(account).await()

    val post =
        OutfitPost(
            postUID = "p_today",
            ownerId = uid,
            name = "bob",
            description = "today's outfit",
            outfitURL = "https://example.com/fake.jpg",
            timestamp = System.currentTimeMillis())
    FirebaseEmulator.firestore.collection("posts").document(post.postUID).set(post).await()

    // Wait for auth listener to load the account
    composeTestRule.waitUntil(timeoutMillis = 5000) {
      viewModel.uiState.value.currentAccount != null
    }

    viewModel.refreshFeedFromFirestore()
    delay(1000)

    val state = viewModel.uiState.first()
    assertTrue(state.hasPostedToday)
    assertTrue(state.feedPosts.any { it.postUID == post.postUID })
  }

  @Test
  fun refreshFeed_loadsLikesAndCountsSuccessfully() = runBlocking {
    val uid = auth.currentUser!!.uid

    val account = Account(uid, uid, "bob", friendUids = listOf(uid))
    FirebaseEmulator.firestore.collection("accounts").document(uid).set(account).await()

    val post =
        OutfitPost(
            postUID = "post1",
            ownerId = uid,
            name = "bob",
            description = "abc",
            outfitURL = "x",
            timestamp = System.currentTimeMillis())
    FirebaseEmulator.firestore.collection("posts").document(post.postUID).set(post).await()

    likesRepository.likePost(
        com.android.ootd.model.posts.Like(
            postId = "post1", postLikerId = uid, timestamp = System.currentTimeMillis()))

    viewModel.setCurrentAccount(account)
    viewModel.refreshFeedFromFirestore()
    delay(600)

    val state = viewModel.uiState.value

    assertTrue(state.likes["post1"] == true)
    assertEquals(1, state.likeCounts["post1"])
  }

  @Test
  fun refresh_noop_whenNoCurrentAccount() = runBlocking {
    // sign out to clear currentAccount
    auth.signOut()
    delay(500)

    // should not throw and should remain cleared
    viewModel.refreshFeedFromFirestore()
    delay(500)

    val state = viewModel.uiState.first()
    assertNull(state.currentAccount)
    assertTrue(state.feedPosts.isEmpty())
  }

  @Test
  fun observeAuth_loadsAccountOnSignIn() = runBlocking {
    // sign out then sign in again to trigger auth listener
    auth.signOut()
    delay(500)
    auth.signInAnonymously().await()

    val uid = auth.currentUser!!.uid
    val account = Account(uid, uid, "carol", friendUids = emptyList())
    FirebaseEmulator.firestore.collection("accounts").document(uid).set(account).await()

    // Wait for auth listener to load the account (use composeTestRule.waitUntil for reliability)
    composeTestRule.waitUntil(timeoutMillis = 5000) {
      viewModel.uiState.value.currentAccount != null
    }

    val state = viewModel.uiState.first()
    assertNotNull(state.currentAccount)
    assertEquals("carol", state.currentAccount?.username)
  }

  @Test
  fun toggleLike_addsLikeAndUpdatesUiState() = runBlocking {
    val uid = auth.currentUser!!.uid

    val account = Account(uid, uid, "bob", friendUids = emptyList())
    FirebaseEmulator.firestore.collection("accounts").document(uid).set(account).await()

    val post =
        OutfitPost(
            postUID = "p_toggle",
            ownerId = uid,
            name = "bob",
            description = "",
            outfitURL = "x",
            timestamp = System.currentTimeMillis())
    FirebaseEmulator.firestore.collection("posts").document(post.postUID).set(post).await()

    viewModel.setCurrentAccount(account)
    viewModel.refreshFeedFromFirestore()
    delay(300)

    assertFalse(viewModel.uiState.value.likes["p_toggle"] == true)

    viewModel.onToggleLike("p_toggle")
    delay(300)

    val state = viewModel.uiState.value

    assertTrue(state.likes["p_toggle"] == true)
    assertEquals(1, state.likeCounts["p_toggle"])

    val snap =
        FirebaseEmulator.firestore
            .collection("likes")
            .document("p_toggle")
            .collection("users")
            .document(uid)
            .get()
            .await()

    assertTrue(snap.exists())
  }

  private fun waitUntilFeedLoaded(timeoutMillis: Long = 5000) {
    composeTestRule.waitUntil(timeoutMillis) { !viewModel.uiState.value.isLoading }
  }
}
