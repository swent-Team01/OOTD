package com.android.ootd.ui.post

import com.android.ootd.model.account.AccountRepository
import com.android.ootd.model.authentication.AccountService
import com.android.ootd.model.items.ImageData
import com.android.ootd.model.items.Item
import com.android.ootd.model.items.ItemsRepository
import com.android.ootd.model.post.OutfitPostRepository
import com.android.ootd.model.posts.LikesRepository
import com.android.ootd.model.posts.OutfitPost
import com.android.ootd.model.user.User
import com.android.ootd.model.user.UserRepository
import io.mockk.clearAllMocks
import io.mockk.coEvery
import io.mockk.coVerify
import io.mockk.every
import io.mockk.mockk
import io.mockk.unmockkAll
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.StandardTestDispatcher
import kotlinx.coroutines.test.advanceUntilIdle
import kotlinx.coroutines.test.resetMain
import kotlinx.coroutines.test.runTest
import kotlinx.coroutines.test.setMain
import org.junit.After
import org.junit.Assert.assertEquals
import org.junit.Assert.assertFalse
import org.junit.Assert.assertNotNull
import org.junit.Assert.assertNull
import org.junit.Assert.assertTrue
import org.junit.Before
import org.junit.Test

/// ** DISCLAIMER: These tests were partly generated by AI and verified by humans */

@OptIn(ExperimentalCoroutinesApi::class)
class PostViewViewModelTest {

  private lateinit var mockPostRepository: OutfitPostRepository
  private lateinit var mockUserRepo: UserRepository
  private lateinit var mockLikesRepo: LikesRepository
  private lateinit var mockAccountService: AccountService
  private lateinit var mockItemsRepo: ItemsRepository
  private lateinit var mockAccountRepo: AccountRepository
  private lateinit var viewModel: PostViewViewModel

  private val testDispatcher = StandardTestDispatcher()

  private val testPost =
      OutfitPost(
          postUID = "test-post-id",
          name = "Test User",
          ownerId = "test-owner-id",
          userProfilePicURL = "https://example.com/profile.jpg",
          outfitURL = "https://example.com/outfit.jpg",
          description = "Test outfit description",
          itemsID = listOf("item1", "item2"),
          timestamp = 1700000000000L)

  private val testOwnerUser =
      User(
          uid = "test-owner-id",
          username = "Test User",
          profilePicture = "https://example.com/profile.jpg")

  private val testItems =
      listOf(
          Item(
              itemUuid = "item1",
              category = "Tops",
              ownerId = "test-owner-id",
              postUuids = listOf("test-post-id"),
              image = ImageData("test_img", "https://example.com/test.jpg")),
          Item(
              itemUuid = "item2",
              category = "Bottoms",
              ownerId = "test-owner-id",
              postUuids = listOf("test-post-id"),
              image = ImageData("test_img", "https://example.com/test.jpg"),
          ))

  @Before
  fun setup() {
    Dispatchers.setMain(testDispatcher)
    mockPostRepository = mockk(relaxed = true)
    mockUserRepo = mockk(relaxed = true)
    mockLikesRepo = mockk(relaxed = true)
    mockAccountService = mockk(relaxed = true)
    mockItemsRepo = mockk(relaxed = true)
    mockAccountRepo = mockk(relaxed = true)

    every { mockAccountService.currentUserId } returns "currentUser"
  }

  @After
  fun tearDown() {
    Dispatchers.resetMain()
    clearAllMocks()
    unmockkAll()
  }

  @Test
  fun uiState_initializes_with_default_values() {
    viewModel =
        PostViewViewModel(
            "",
            mockPostRepository,
            mockUserRepo,
            mockLikesRepo,
            mockAccountService,
            mockItemsRepo,
            mockAccountRepo)

    val state = viewModel.uiState.value
    assertNull(state.post)
    assertFalse(state.isLoading)
    assertNull(state.error)
    assertTrue(state.likedByUsers.isEmpty())
    assertTrue(state.items.isEmpty())
    assertTrue(state.starredItemIds.isEmpty())
  }

  @Test
  fun init_loads_everything_when_postId_is_valid() = runTest {
    // Mock all repositories
    coEvery { mockPostRepository.getPostById("test-post-id") } returns testPost
    coEvery { mockUserRepo.getUser("test-owner-id") } returns testOwnerUser
    coEvery { mockLikesRepo.getLikesForPost("test-post-id") } returns emptyList()
    coEvery { mockItemsRepo.getFriendItemsForPost("test-post-id", "test-owner-id") } returns
        testItems
    coEvery { mockAccountRepo.getStarredItems("currentUser") } returns emptyList()

    // Create ViewModel with valid postId
    viewModel =
        PostViewViewModel(
            "test-post-id",
            mockPostRepository,
            mockUserRepo,
            mockLikesRepo,
            mockAccountService,
            mockItemsRepo,
            mockAccountRepo)

    advanceUntilIdle()

    // Everything should be loaded
    val state = viewModel.uiState.value
    assertNotNull(state.post)
    assertEquals("test-post-id", state.post?.postUID)
    assertEquals("Test User", state.ownerUsername)
    assertEquals(2, state.items.size)
    assertTrue(state.starredItemIds.isEmpty())
    assertFalse(state.isLoading)
    assertNull(state.error)
  }

  @Test
  fun init_does_not_load_when_postId_is_empty() = runTest {
    viewModel =
        PostViewViewModel(
            "",
            mockPostRepository,
            mockUserRepo,
            mockLikesRepo,
            mockAccountService,
            mockItemsRepo,
            mockAccountRepo)
    advanceUntilIdle()

    val state = viewModel.uiState.value
    assertNull(state.post)
    assertFalse(state.isLoading)
    assertNull(state.error)

    // Verify repositories were never called
    coVerify(exactly = 0) { mockPostRepository.getPostById(any()) }
    coVerify(exactly = 0) { mockItemsRepo.getFriendItemsForPost(any(), any()) }
  }

  @Test
  fun loadPostWithItems_sets_loading_true_initially() = runTest {
    // Arrange: Delay the response to check loading state
    coEvery { mockPostRepository.getPostById("test-post-id") } coAnswers
        {
          kotlinx.coroutines.delay(100)
          testPost
        }
    coEvery { mockUserRepo.getUser("test-owner-id") } returns testOwnerUser
    coEvery { mockLikesRepo.getLikesForPost("test-post-id") } returns emptyList()
    coEvery { mockItemsRepo.getFriendItemsForPost("test-post-id", "test-owner-id") } returns
        testItems
    coEvery { mockAccountRepo.getStarredItems("currentUser") } returns emptyList()

    // Create ViewModel (triggers init which calls loadPostWithItems)
    viewModel =
        PostViewViewModel(
            "test-post-id",
            mockPostRepository,
            mockUserRepo,
            mockLikesRepo,
            mockAccountService,
            mockItemsRepo,
            mockAccountRepo)

    // Loading should be true before completion
    assertTrue(viewModel.uiState.value.isLoading)

    advanceUntilIdle()

    // After completion, loading should be false
    assertFalse(viewModel.uiState.value.isLoading)
  }

  @Test
  fun loadPostWithItems_successfully_loads_all_data_in_parallel() = runTest {
    // Arrange
    coEvery { mockPostRepository.getPostById("test-post-id") } returns testPost
    coEvery { mockUserRepo.getUser("test-owner-id") } returns testOwnerUser
    coEvery { mockLikesRepo.getLikesForPost("test-post-id") } returns emptyList()
    coEvery { mockItemsRepo.getFriendItemsForPost("test-post-id", "test-owner-id") } returns
        testItems
    coEvery { mockAccountRepo.getStarredItems("currentUser") } returns listOf("item1")

    // Act
    viewModel =
        PostViewViewModel(
            "test-post-id",
            mockPostRepository,
            mockUserRepo,
            mockLikesRepo,
            mockAccountService,
            mockItemsRepo,
            mockAccountRepo)

    advanceUntilIdle()

    // Assert
    val state = viewModel.uiState.value
    assertNotNull(state.post)
    assertEquals("test-post-id", state.post?.postUID)
    assertEquals("Test User", state.ownerUsername)
    assertEquals("https://example.com/profile.jpg", state.ownerProfilePicture)
    assertTrue(state.likedByUsers.isEmpty())
    assertFalse(state.isLikedByCurrentUser)
    assertEquals(2, state.items.size)
    assertEquals(setOf("item1"), state.starredItemIds)
    assertFalse(state.isLoading)
    assertNull(state.error)
  }

  @Test
  fun loadPostWithItems_handles_post_failure() = runTest {
    // Post fails to load
    coEvery { mockPostRepository.getPostById("test-post-id") } returns null
    coEvery { mockItemsRepo.getFriendItemsForPost(any(), any()) } returns testItems
    coEvery { mockAccountRepo.getStarredItems("currentUser") } returns emptyList()

    // Act
    viewModel =
        PostViewViewModel(
            "test-post-id",
            mockPostRepository,
            mockUserRepo,
            mockLikesRepo,
            mockAccountService,
            mockItemsRepo,
            mockAccountRepo)

    advanceUntilIdle()

    // Should show error
    val state = viewModel.uiState.value
    assertNull(state.post)
    assertFalse(state.isLoading)
    assertEquals("Unable to load post. Please try again.", state.error)
  }

  @Test
  fun loadPostWithItems_handles_items_failure_gracefully() = runTest {
    // Post loads but items fail
    coEvery { mockPostRepository.getPostById("test-post-id") } returns testPost
    coEvery { mockUserRepo.getUser("test-owner-id") } returns testOwnerUser
    coEvery { mockLikesRepo.getLikesForPost("test-post-id") } returns emptyList()
    coEvery { mockItemsRepo.getFriendItemsForPost("test-post-id", "test-owner-id") } throws
        Exception("Network error")
    coEvery { mockAccountRepo.getStarredItems("currentUser") } returns emptyList()

    // Act
    viewModel =
        PostViewViewModel(
            "test-post-id",
            mockPostRepository,
            mockUserRepo,
            mockLikesRepo,
            mockAccountService,
            mockItemsRepo,
            mockAccountRepo)

    advanceUntilIdle()

    // Should show post with partial error
    val state = viewModel.uiState.value
    assertNotNull(state.post)
    assertEquals("test-post-id", state.post?.postUID)
    assertTrue(state.items.isEmpty())
    assertFalse(state.isLoading)
    assertEquals("Post loaded, but items could not be loaded.", state.error)
  }

  @Test
  fun loadPostWithItems_handles_exception() = runTest {
    // Exception during load
    val errorMessage = "Unable to load post. Please try again."
    coEvery { mockPostRepository.getPostById("test-post-id") } throws Exception(errorMessage)

    // Act
    viewModel =
        PostViewViewModel(
            "test-post-id",
            mockPostRepository,
            mockUserRepo,
            mockLikesRepo,
            mockAccountService,
            mockItemsRepo,
            mockAccountRepo)

    advanceUntilIdle()

    // Assert
    val state = viewModel.uiState.value
    assertNull(state.post)
    assertFalse(state.isLoading)
    assertEquals(errorMessage, state.error)
  }

  @Test
  fun toggleStar_updates_starredItemIds() = runTest {
    // Initial setup with items loaded
    coEvery { mockPostRepository.getPostById("test-post-id") } returns testPost
    coEvery { mockUserRepo.getUser("test-owner-id") } returns testOwnerUser
    coEvery { mockLikesRepo.getLikesForPost("test-post-id") } returns emptyList()
    coEvery { mockItemsRepo.getFriendItemsForPost("test-post-id", "test-owner-id") } returns
        testItems
    coEvery { mockAccountRepo.getStarredItems("currentUser") } returns emptyList()

    viewModel =
        PostViewViewModel(
            "test-post-id",
            mockPostRepository,
            mockUserRepo,
            mockLikesRepo,
            mockAccountService,
            mockItemsRepo,
            mockAccountRepo)

    advanceUntilIdle()

    // Initially no starred items
    assertTrue(viewModel.uiState.value.starredItemIds.isEmpty())

    // Mock toggle star response
    coEvery { mockAccountRepo.toggleStarredItem("item1") } returns listOf("item1")

    // Toggle star for item1
    viewModel.toggleStar(testItems[0])
    advanceUntilIdle()

    // item1 should now be starred
    assertEquals(setOf("item1"), viewModel.uiState.value.starredItemIds)
  }

  @Test
  fun toggleStar_handles_error() = runTest {
    // Arrange
    coEvery { mockPostRepository.getPostById("test-post-id") } returns testPost
    coEvery { mockUserRepo.getUser("test-owner-id") } returns testOwnerUser
    coEvery { mockLikesRepo.getLikesForPost("test-post-id") } returns emptyList()
    coEvery { mockItemsRepo.getFriendItemsForPost("test-post-id", "test-owner-id") } returns
        testItems
    coEvery { mockAccountRepo.getStarredItems("currentUser") } returns emptyList()

    viewModel =
        PostViewViewModel(
            "test-post-id",
            mockPostRepository,
            mockUserRepo,
            mockLikesRepo,
            mockAccountService,
            mockItemsRepo,
            mockAccountRepo)

    advanceUntilIdle()

    // Mock toggle star to throw exception
    coEvery { mockAccountRepo.toggleStarredItem("item1") } throws Exception("Network error")

    // Act
    viewModel.toggleStar(testItems[0])
    advanceUntilIdle()

    // Error should be set
    assertEquals("Couldn't update wishlist. Please try again.", viewModel.uiState.value.error)
  }

  @Test
  fun toggleLike_updates_like_status() = runTest {
    // Initial setup
    coEvery { mockPostRepository.getPostById("test-post-id") } returns testPost
    coEvery { mockUserRepo.getUser("test-owner-id") } returns testOwnerUser
    coEvery { mockLikesRepo.getLikesForPost("test-post-id") } returns emptyList()
    coEvery { mockItemsRepo.getFriendItemsForPost("test-post-id", "test-owner-id") } returns
        testItems
    coEvery { mockAccountRepo.getStarredItems("currentUser") } returns emptyList()
    coEvery { mockLikesRepo.likePost(any()) } returns Unit
    coEvery { mockLikesRepo.unlikePost(any(), any()) } returns Unit

    viewModel =
        PostViewViewModel(
            "test-post-id",
            mockPostRepository,
            mockUserRepo,
            mockLikesRepo,
            mockAccountService,
            mockItemsRepo,
            mockAccountRepo)

    advanceUntilIdle()

    // Initially not liked
    assertFalse(viewModel.uiState.value.isLikedByCurrentUser)

    // Toggle like
    viewModel.toggleLike()
    advanceUntilIdle()

    // Like should be called
    coVerify { mockLikesRepo.likePost(any()) }
  }

  @Test
  fun savePostEdits_updates_post_successfully() = runTest {
    // Arrange
    coEvery { mockPostRepository.getPostById("test-post-id") } returns testPost
    coEvery { mockUserRepo.getUser("test-owner-id") } returns testOwnerUser
    coEvery { mockLikesRepo.getLikesForPost("test-post-id") } returns emptyList()
    coEvery { mockItemsRepo.getFriendItemsForPost("test-post-id", "test-owner-id") } returns
        testItems
    coEvery { mockAccountRepo.getStarredItems("currentUser") } returns emptyList()
    coEvery { mockPostRepository.updatePostFields(any(), any()) } returns Unit

    viewModel =
        PostViewViewModel(
            "test-post-id",
            mockPostRepository,
            mockUserRepo,
            mockLikesRepo,
            mockAccountService,
            mockItemsRepo,
            mockAccountRepo)

    advanceUntilIdle()

    // Update post
    val newDescription = "Updated description"
    val newLocation =
        com.android.ootd.model.map.Location(name = "New Location", latitude = 0.0, longitude = 0.0)
    viewModel.savePostEdits(newDescription, newLocation)
    advanceUntilIdle()

    // updatePostFields should be called
    coVerify {
      mockPostRepository.updatePostFields(
          "test-post-id", match { updates -> updates["description"] == newDescription })
    }
  }

  @Test
  fun deletePost_calls_onSuccess_when_successful() = runTest {
    // Arrange
    coEvery { mockPostRepository.getPostById("test-post-id") } returns testPost
    coEvery { mockUserRepo.getUser("test-owner-id") } returns testOwnerUser
    coEvery { mockLikesRepo.getLikesForPost("test-post-id") } returns emptyList()
    coEvery { mockItemsRepo.getFriendItemsForPost("test-post-id", "test-owner-id") } returns
        testItems
    coEvery { mockAccountRepo.getStarredItems("currentUser") } returns emptyList()
    coEvery { mockPostRepository.deletePost("test-post-id") } returns Unit

    viewModel =
        PostViewViewModel(
            "test-post-id",
            mockPostRepository,
            mockUserRepo,
            mockLikesRepo,
            mockAccountService,
            mockItemsRepo,
            mockAccountRepo)

    advanceUntilIdle()

    // Act
    var successCalled = false
    var errorCalled = false
    viewModel.deletePost(onSuccess = { successCalled = true }, onError = { errorCalled = true })
    advanceUntilIdle()

    // Assert
    assertTrue(successCalled)
    assertFalse(errorCalled)
    coVerify { mockPostRepository.deletePost("test-post-id") }
  }

  @Test
  fun deletePost_calls_onError_when_fails() = runTest {
    coEvery { mockPostRepository.getPostById("test-post-id") } returns testPost
    coEvery { mockUserRepo.getUser("test-owner-id") } returns testOwnerUser
    coEvery { mockLikesRepo.getLikesForPost("test-post-id") } returns emptyList()
    coEvery { mockItemsRepo.getFriendItemsForPost("test-post-id", "test-owner-id") } returns
        testItems
    coEvery { mockAccountRepo.getStarredItems("currentUser") } returns emptyList()
    coEvery { mockPostRepository.deletePost("test-post-id") } throws Exception("Delete failed")

    viewModel =
        PostViewViewModel(
            "test-post-id",
            mockPostRepository,
            mockUserRepo,
            mockLikesRepo,
            mockAccountService,
            mockItemsRepo,
            mockAccountRepo)

    advanceUntilIdle()

    var successCalled = false
    var errorMessage = ""
    viewModel.deletePost(onSuccess = { successCalled = true }, onError = { errorMessage = it })
    advanceUntilIdle()

    assertFalse(successCalled)
    assertEquals("Failed to delete post", errorMessage)
    assertEquals("Failed to delete post", viewModel.uiState.value.error)
  }

  @Test
  fun clearError_clears_error_message() = runTest {
    // Create error state
    coEvery { mockPostRepository.getPostById("test-post-id") } returns null

    viewModel =
        PostViewViewModel(
            "test-post-id",
            mockPostRepository,
            mockUserRepo,
            mockLikesRepo,
            mockAccountService,
            mockItemsRepo,
            mockAccountRepo)

    advanceUntilIdle()

    // Verify error is set
    assertNotNull(viewModel.uiState.value.error)

    // Clear error
    viewModel.clearError()

    // Error should be null
    assertNull(viewModel.uiState.value.error)
  }

  @Test
  fun refreshStarredItems_updates_starred_items() = runTest {
    // Arrange
    coEvery { mockPostRepository.getPostById("test-post-id") } returns testPost
    coEvery { mockUserRepo.getUser("test-owner-id") } returns testOwnerUser
    coEvery { mockLikesRepo.getLikesForPost("test-post-id") } returns emptyList()
    coEvery { mockItemsRepo.getFriendItemsForPost("test-post-id", "test-owner-id") } returns
        testItems
    coEvery { mockAccountRepo.getStarredItems("currentUser") } returns emptyList()

    viewModel =
        PostViewViewModel(
            "test-post-id",
            mockPostRepository,
            mockUserRepo,
            mockLikesRepo,
            mockAccountService,
            mockItemsRepo,
            mockAccountRepo)

    advanceUntilIdle()

    // Initially empty
    assertTrue(viewModel.uiState.value.starredItemIds.isEmpty())

    // Mock new starred items
    coEvery { mockAccountRepo.getStarredItems("currentUser") } returns listOf("item1", "item2")

    // Refresh
    viewModel.refreshStarredItems()
    advanceUntilIdle()

    // Should have new starred items
    assertEquals(setOf("item1", "item2"), viewModel.uiState.value.starredItemIds)
  }
}
