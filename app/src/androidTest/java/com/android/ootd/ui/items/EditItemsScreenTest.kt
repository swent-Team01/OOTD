package com.android.ootd.ui.post

import android.net.Uri
import androidx.compose.ui.test.*
import androidx.compose.ui.test.junit4.createComposeRule
import androidx.compose.ui.test.swipeUp
import com.android.ootd.model.items.ImageData
import com.android.ootd.model.items.Item
import com.android.ootd.model.items.ItemsRepositoryLocal
import com.android.ootd.model.items.ItemsRepositoryProvider
import com.android.ootd.model.items.Material
import junit.framework.TestCase.assertEquals
import kotlinx.coroutines.delay
import kotlinx.coroutines.test.runTest
import org.junit.After
import org.junit.Before
import org.junit.Rule
import org.junit.Test

// Test partially generated by the AI coding agent: Claude Sonnet 4.5
class EditItemsScreenTest {

  @get:Rule val composeTestRule = createComposeRule()

  private lateinit var viewModel: EditItemsViewModel
  private lateinit var repository: ItemsRepositoryLocal
  private var goBackCalled = false

  private val testItem =
      Item(
          itemUuid = "test-item-1",
          postUuids = listOf("test_post2"),
          image = ImageData("test-item-1-photo", "https://example.com/image.jpg"),
          category = "Clothing",
          type = "T-shirt",
          brand = "Nike",
          price = 29.99,
          material =
              listOf(
                  Material(name = "Cotton", percentage = 80.0),
                  Material(name = "Polyester", percentage = 20.0)),
          link = "https://nike.com/tshirt",
          ownerId = "user123")

  @Before
  fun setUp() {
    // Use local repository for testing
    ItemsRepositoryProvider.useLocal()
    repository = ItemsRepositoryProvider.getLocalRepository()!!
    repository.clearAll()

    // Create ViewModel
    viewModel = EditItemsViewModel(repository)

    // Reset callbacks
    goBackCalled = false
  }

  @After
  fun tearDown() {
    repository.clearAll()
    ItemsRepositoryProvider.reset()
  }

  // Helper function to ensure a node is visible by scrolling if necessary
  private fun ensureVisible(tag: String) {
    // Already displayed? Nothing to do.
    val alreadyVisible =
        runCatching {
              composeTestRule.onNodeWithTag(tag, useUnmergedTree = true).assertIsDisplayed()
            }
            .isSuccess
    if (alreadyVisible) return

    // Fallback: manual swipes a few times (helps when semantics are quirky but visual scroll
    // still works).
    repeat(5) {
      composeTestRule.onNodeWithTag(EditItemsScreenTestTags.ALL_FIELDS).performTouchInput {
        swipeUp(startY = bottom, endY = top)
      }
      composeTestRule.waitForIdle()
      if (runCatching {
            composeTestRule.onNodeWithTag(tag, useUnmergedTree = true).assertIsDisplayed()
          }
          .isSuccess)
          return
    }
  }

  @Test
  fun loadItemPopulatesAllFields() {
    composeTestRule.setContent { EditItemsScreen(testItem.itemUuid, viewModel) }

    // Load item into ViewModel
    composeTestRule.runOnIdle { viewModel.loadItem(testItem) }

    // Wait for UI to update
    composeTestRule.waitForIdle()

    // Verify all fields are populated
    composeTestRule
        .onNodeWithTag(EditItemsScreenTestTags.INPUT_ITEM_CATEGORY)
        .assertTextEquals("Category", "Clothing")

    composeTestRule
        .onNodeWithTag(EditItemsScreenTestTags.INPUT_ITEM_TYPE)
        .assertTextEquals("Type", "T-shirt")

    composeTestRule
        .onNodeWithTag(EditItemsScreenTestTags.INPUT_ITEM_BRAND)
        .assertTextEquals("Brand", "Nike")

    composeTestRule
        .onNodeWithTag(EditItemsScreenTestTags.INPUT_ITEM_PRICE)
        .assertTextEquals("Price", "29.99")

    composeTestRule
        .onNodeWithTag(EditItemsScreenTestTags.INPUT_ITEM_MATERIAL)
        .assertTextContains("Cotton 80.0%, Polyester 20.0%")

    composeTestRule
        .onNodeWithTag(EditItemsScreenTestTags.INPUT_ITEM_LINK)
        .assertTextEquals("Link", "https://nike.com/tshirt")
  }

  @Test
  fun saveButtonIsDisabledWhenRequiredFieldsAreEmpty() {
    composeTestRule.setContent { EditItemsScreen(testItem.itemUuid, viewModel) }

    composeTestRule.waitForIdle()

    // Ensure button is visible
    ensureVisible(EditItemsScreenTestTags.BUTTON_SAVE_CHANGES)

    // Initially, save button should be disabled (no image, no category)
    composeTestRule.onNodeWithTag(EditItemsScreenTestTags.BUTTON_SAVE_CHANGES).assertIsNotEnabled()
  }

  @Test
  fun saveButtonIsEnabledWhenRequiredFieldsAreFilled() {
    composeTestRule.setContent { EditItemsScreen(testItem.itemUuid, viewModel) }

    // Set image and category
    composeTestRule.runOnIdle {
      viewModel.setPhoto(Uri.parse("https://example.com/test.jpg"))
      viewModel.setCategory("Clothing")
    }

    composeTestRule.waitForIdle()

    // Ensure button is visible
    ensureVisible(EditItemsScreenTestTags.BUTTON_SAVE_CHANGES)

    // Save button should now be enabled
    composeTestRule.onNodeWithTag(EditItemsScreenTestTags.BUTTON_SAVE_CHANGES).assertIsEnabled()
  }

  @Test
  fun deleteButtonIsDisabledWhenNoItemLoaded() {
    composeTestRule.setContent { EditItemsScreen(testItem.itemUuid, viewModel) }

    composeTestRule.waitForIdle()

    // Ensure button is visible
    ensureVisible(EditItemsScreenTestTags.BUTTON_DELETE_ITEM)

    // Delete button should be disabled when no item is loaded
    composeTestRule.onNodeWithTag(EditItemsScreenTestTags.BUTTON_DELETE_ITEM).assertIsNotEnabled()
  }

  @Test
  fun deleteButtonIsEnabledWhenItemIsLoaded() {
    composeTestRule.setContent { EditItemsScreen(testItem.itemUuid, viewModel) }

    composeTestRule.runOnIdle { viewModel.loadItem(testItem) }

    composeTestRule.waitForIdle()

    // Ensure button is visible
    ensureVisible(EditItemsScreenTestTags.BUTTON_DELETE_ITEM)

    // Delete button should be enabled
    composeTestRule.onNodeWithTag(EditItemsScreenTestTags.BUTTON_DELETE_ITEM).assertIsEnabled()
  }

  @Test
  fun userCanEditCategoryField() {
    composeTestRule.setContent { EditItemsScreen(testItem.itemUuid, viewModel) }

    composeTestRule.runOnIdle { viewModel.loadItem(testItem) }

    composeTestRule.waitForIdle()

    // Ensure field is visible
    ensureVisible(EditItemsScreenTestTags.INPUT_ITEM_CATEGORY)

    // Edit category
    composeTestRule
        .onNodeWithTag(EditItemsScreenTestTags.INPUT_ITEM_CATEGORY)
        .performTextClearance()
    composeTestRule
        .onNodeWithTag(EditItemsScreenTestTags.INPUT_ITEM_CATEGORY)
        .performTextInput("Shoes")

    // Verify change
    composeTestRule
        .onNodeWithTag(EditItemsScreenTestTags.INPUT_ITEM_CATEGORY)
        .assertTextContains("Shoes")
  }

  @Test
  fun userCanEditTypeField() {
    composeTestRule.setContent { EditItemsScreen(testItem.itemUuid, viewModel) }

    composeTestRule.runOnIdle { viewModel.loadItem(testItem) }

    composeTestRule.waitForIdle()

    // Ensure field is visible
    ensureVisible(EditItemsScreenTestTags.INPUT_ITEM_TYPE)

    // Edit type
    composeTestRule.onNodeWithTag(EditItemsScreenTestTags.INPUT_ITEM_TYPE).performTextClearance()
    composeTestRule
        .onNodeWithTag(EditItemsScreenTestTags.INPUT_ITEM_TYPE)
        .performTextInput("Hoodie")

    // Verify change
    composeTestRule
        .onNodeWithTag(EditItemsScreenTestTags.INPUT_ITEM_TYPE)
        .assertTextContains("Hoodie")
  }

  @Test
  fun userCanEditBrandField() {
    composeTestRule.setContent { EditItemsScreen(testItem.itemUuid, viewModel) }

    composeTestRule.runOnIdle { viewModel.loadItem(testItem) }

    composeTestRule.waitForIdle()

    // Ensure field is visible
    ensureVisible(EditItemsScreenTestTags.INPUT_ITEM_BRAND)

    // Edit brand
    composeTestRule.onNodeWithTag(EditItemsScreenTestTags.INPUT_ITEM_BRAND).performTextClearance()
    composeTestRule
        .onNodeWithTag(EditItemsScreenTestTags.INPUT_ITEM_BRAND)
        .performTextInput("Adidas")

    // Verify change
    composeTestRule
        .onNodeWithTag(EditItemsScreenTestTags.INPUT_ITEM_BRAND)
        .assertTextContains("Adidas")
  }

  @Test
  fun userCanEditPriceField() {
    composeTestRule.setContent { EditItemsScreen(testItem.itemUuid, viewModel) }

    composeTestRule.runOnIdle { viewModel.loadItem(testItem) }

    composeTestRule.waitForIdle()

    // Ensure field is visible
    ensureVisible(EditItemsScreenTestTags.INPUT_ITEM_PRICE)

    // Edit price
    composeTestRule.onNodeWithTag(EditItemsScreenTestTags.INPUT_ITEM_PRICE).performTextClearance()
    composeTestRule
        .onNodeWithTag(EditItemsScreenTestTags.INPUT_ITEM_PRICE)
        .performTextInput("49.99")

    // Verify change
    composeTestRule
        .onNodeWithTag(EditItemsScreenTestTags.INPUT_ITEM_PRICE)
        .assertTextContains("49.99")
  }

  @Test
  fun userCanEditLinkField() {
    composeTestRule.setContent { EditItemsScreen(testItem.itemUuid, viewModel) }

    composeTestRule.runOnIdle { viewModel.loadItem(testItem) }

    composeTestRule.waitForIdle()

    // Ensure field is visible
    ensureVisible(EditItemsScreenTestTags.INPUT_ITEM_LINK)

    // Edit link
    composeTestRule.onNodeWithTag(EditItemsScreenTestTags.INPUT_ITEM_LINK).performTextClearance()
    composeTestRule
        .onNodeWithTag(EditItemsScreenTestTags.INPUT_ITEM_LINK)
        .performTextInput("https://adidas.com")

    // Verify change
    composeTestRule
        .onNodeWithTag(EditItemsScreenTestTags.INPUT_ITEM_LINK)
        .assertTextContains("https://adidas.com")
  }

  @Test
  fun userCanEditMaterialField() {
    composeTestRule.setContent { EditItemsScreen(testItem.itemUuid, viewModel) }

    composeTestRule.runOnIdle { viewModel.loadItem(testItem) }

    composeTestRule.waitForIdle()

    // Ensure field is visible
    ensureVisible(EditItemsScreenTestTags.INPUT_ITEM_MATERIAL)

    // Edit material field
    composeTestRule
        .onNodeWithTag(EditItemsScreenTestTags.INPUT_ITEM_MATERIAL)
        .performTextClearance()
    composeTestRule
        .onNodeWithTag(EditItemsScreenTestTags.INPUT_ITEM_MATERIAL)
        .performTextInput("Wool 50%, Cotton 50%")

    // Verify change
    composeTestRule
        .onNodeWithTag(EditItemsScreenTestTags.INPUT_ITEM_MATERIAL)
        .assertTextContains("Wool 50%, Cotton 50%")
  }

  @Test
  fun typeSuggestionsAppearOnFocus() {
    composeTestRule.setContent { EditItemsScreen(testItem.itemUuid, viewModel) }

    // Set category to enable suggestions
    composeTestRule.runOnIdle { viewModel.setCategory("Clothing") }

    composeTestRule.waitForIdle()

    // Focus on type field
    composeTestRule.onNodeWithTag(EditItemsScreenTestTags.INPUT_ITEM_TYPE).performClick()

    composeTestRule.waitForIdle()

    // Wait for suggestions to appear
    composeTestRule.waitUntil(timeoutMillis = 5_000) {
      composeTestRule.onAllNodesWithText("T-shirt").fetchSemanticsNodes().isNotEmpty()
    }

    // Verify suggestions appear (checking for common clothing types)
    composeTestRule.onNodeWithText("T-shirt").assertExists()
    composeTestRule.onNodeWithText("Jacket").assertExists()
  }

  @Test
  fun selectingSuggestionFillsTypeField() {
    composeTestRule.setContent { EditItemsScreen(testItem.itemUuid, viewModel) }

    // Set category
    composeTestRule.runOnIdle { viewModel.setCategory("Shoes") }

    composeTestRule.waitForIdle()

    // Focus on type field to show suggestions
    composeTestRule.onNodeWithTag(EditItemsScreenTestTags.INPUT_ITEM_TYPE).performClick()

    composeTestRule.waitForIdle()

    // Wait for suggestions to appear before clicking
    composeTestRule.waitUntil(timeoutMillis = 5_000) {
      composeTestRule.onAllNodesWithText("Sneakers").fetchSemanticsNodes().isNotEmpty()
    }

    // Click a suggestion
    composeTestRule.onNodeWithText("Sneakers").performClick()

    // Verify type field is filled
    composeTestRule
        .onNodeWithTag(EditItemsScreenTestTags.INPUT_ITEM_TYPE)
        .assertTextContains("Sneakers")
  }

  @Test
  fun invalidPriceInputHandledGracefully() {
    composeTestRule.setContent { EditItemsScreen(testItem.itemUuid, viewModel) }

    // Try to input invalid price
    composeTestRule
        .onNodeWithTag(EditItemsScreenTestTags.INPUT_ITEM_PRICE)
        .performTextInput("invalid")

    composeTestRule.waitForIdle()

    // Should default to 0.0 or empty
    composeTestRule.runOnIdle {
      val state = viewModel.uiState.value
      assertEquals(0.0, state.price)
    }
  }

  @Test
  fun uploadingOverlay_isNotVisible_whenNotLoading() {
    composeTestRule.setContent { EditItemsScreen(testItem.itemUuid, viewModel) }

    // Initially, isLoading should be false
    composeTestRule.runOnIdle { assert(!viewModel.uiState.value.isLoading) }

    // Verify the overlay text is not visible
    composeTestRule.onAllNodesWithText("Uploading item...").assertCountEquals(0)
  }

  @Test
  fun uploadingOverlay_appearsWhenSavingItem() = runTest {
    composeTestRule.setContent { EditItemsScreen(testItem.itemUuid, viewModel) }

    // Load test item
    composeTestRule.runOnIdle { viewModel.loadItem(testItem) }

    composeTestRule.waitForIdle()

    // Modify something to trigger save
    composeTestRule.runOnIdle { viewModel.setBrand("Adidas") }

    composeTestRule.waitForIdle()

    // Trigger save action
    composeTestRule.runOnIdle { viewModel.onSaveItemClick() }

    // Wait a brief moment for the loading state to be set
    composeTestRule.waitForIdle()

    // Verify loading overlay appears during the operation
    var loadingWasShown = false
    composeTestRule.runOnIdle {
      // Check if loading is currently true or if the operation completed very quickly
      loadingWasShown =
          viewModel.uiState.value.isLoading || viewModel.uiState.value.isSaveSuccessful
    }

    // At least one of these should be true - either still loading or already succeeded
    assert(loadingWasShown)
  }

  @Test
  fun uploadingOverlay_hidesAfterItemSaved() = runTest {
    composeTestRule.setContent { EditItemsScreen(testItem.itemUuid, viewModel) }

    // Load and modify item
    composeTestRule.runOnIdle {
      viewModel.loadItem(testItem)
      viewModel.setPrice(39.99)
    }

    composeTestRule.waitForIdle()

    // Trigger save
    composeTestRule.runOnIdle { viewModel.onSaveItemClick() }

    // Wait for the operation to complete
    composeTestRule.waitForIdle()
    delay(1000) // Give time for async operation

    // Verify loading is no longer shown after completion
    composeTestRule.runOnIdle {
      // After the operation completes, isLoading should be false
      assert(!viewModel.uiState.value.isLoading)
    }

    // Verify overlay text is not visible
    composeTestRule.onAllNodesWithText("Uploading item...").assertCountEquals(0)
  }
}
