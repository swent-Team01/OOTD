package com.android.ootd.ui.post

import android.net.Uri
import androidx.core.content.FileProvider
import androidx.test.platform.app.InstrumentationRegistry
import com.android.ootd.model.authentication.AccountService
import com.android.ootd.model.items.ImageData
import com.android.ootd.model.items.Item
import com.android.ootd.model.items.Material
import com.android.ootd.model.post.OutfitPostRepositoryFirestore
import com.android.ootd.model.user.UserRepository
import com.android.ootd.model.user.UserRepositoryProvider
import com.android.ootd.utils.FirebaseEmulator
import com.android.ootd.utils.FirestoreTest
import io.mockk.every
import io.mockk.mockk
import java.io.File
import junit.framework.TestCase.assertEquals
import junit.framework.TestCase.assertFalse
import junit.framework.TestCase.assertNotNull
import junit.framework.TestCase.assertNull
import junit.framework.TestCase.assertTrue
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.runBlocking
import kotlinx.coroutines.tasks.await
import org.junit.Before
import org.junit.Test

/** DISCLAIMER: These tests were partly generated by AI and verified by humans */
class OutfitPreviewViewModelFirebaseTest : FirestoreTest() {

  private lateinit var viewModel: OutfitPreviewViewModel
  private lateinit var postRepository: OutfitPostRepositoryFirestore
  private lateinit var accountService: AccountService
  private lateinit var testUserRepository: UserRepository
  private lateinit var realUid: String

  @Before
  override fun setUp() {
    super.setUp()

    postRepository =
        OutfitPostRepositoryFirestore(FirebaseEmulator.firestore, FirebaseEmulator.storage)
    testUserRepository = UserRepositoryProvider.repository

    realUid = FirebaseEmulator.auth.currentUser?.uid ?: "fallback-uid"

    accountService = mockk(relaxed = true)
    every { accountService.currentUserId } returns realUid

    // Ensure a matching Firestore user exists
    runBlocking { createTestUser(realUid) }

    viewModel =
        OutfitPreviewViewModel(
            itemsRepository = itemsRepository,
            postRepository = postRepository,
            userRepository = testUserRepository,
            accountService = accountService)
  }

  /** Creates a fake Firestore user so userRepository.getUser() works and passes rules. */
  private suspend fun createTestUser(uid: String) {
    val userData =
        hashMapOf(
            "uid" to uid,
            "ownerId" to uid, // Required by Firestore rules
            "username" to "TestUser",
            "profilePicture" to "https://example.com/profile.jpg")
    FirebaseEmulator.firestore.collection("users").document(uid).set(userData).await()
  }

  private fun createTempImageFile(): File {
    val context = InstrumentationRegistry.getInstrumentation().targetContext
    val file = File(context.cacheDir, "test_outfit_${System.currentTimeMillis()}.jpg")
    // Write a small JPEG-like header + dummy data
    file.writeBytes(
        byteArrayOf(0xFF.toByte(), 0xD8.toByte(), 0xFF.toByte(), 0xE0.toByte()) +
            ByteArray(1024) { 0xAB.toByte() })
    return file
  }

  private fun createReadableUri(): Uri {
    val context = InstrumentationRegistry.getInstrumentation().targetContext
    val file = createTempImageFile()
    return FileProvider.getUriForFile(context, "${context.packageName}.provider", file)
  }

  private suspend fun createTestItem(postUuid: String): Item {
    val item =
        Item(
            itemUuid = itemsRepository.getNewItemId(),
            postUuids = listOf(postUuid),
            image = ImageData("test_img", "https://example.com/test.jpg"),
            category = "Clothing",
            type = "T-Shirt",
            brand = "TestBrand",
            price = 29.99,
            material = listOf(Material("Cotton", 100.0)),
            link = "https://example.com/item",
            ownerId = realUid)
    itemsRepository.addItem(item)
    return item
  }

  @Test
  fun publishPost_withValidData_successfullySavesPostAndUpdatesState() = runBlocking {
    val imageUri = createReadableUri()
    val description = "My awesome outfit for today!"

    val beforeTimestamp = System.currentTimeMillis()
    viewModel.initFromFitCheck(imageUri.toString(), description)
    delay(500)

    val state = viewModel.uiState.first()
    val postUuid = state.postUuid

    createTestItem(postUuid)
    createTestItem(postUuid)

    viewModel.loadItemsForPost()
    delay(500)

    val stateWithItems = viewModel.uiState.first()
    assertEquals(2, stateWithItems.items.size)

    viewModel.publishPost()
    delay(3000)

    val finalState = viewModel.uiState.first()
    assertFalse(finalState.isLoading)
    assertTrue(finalState.isPublished)
    assertEquals("Post created successfully!", finalState.successMessage)

    val afterTimestamp = System.currentTimeMillis()
    val savedPost = postRepository.getPostById(postUuid)
    assertNotNull(savedPost)
    assertTrue(savedPost!!.timestamp >= beforeTimestamp)
    assertTrue(savedPost.timestamp <= afterTimestamp)
    assertEquals(postUuid, savedPost.postUID)
    assertEquals(description, savedPost.description)
    assertEquals(2, savedPost.itemsID.size)
    assertEquals(realUid, savedPost.ownerId)
    assertNotNull(savedPost.name)
    assertTrue(savedPost.outfitURL.isNotEmpty())
  }

  @Test
  fun publishPost_withMissingRequiredData_failsWithErrorMessage() = runBlocking {
    viewModel.initFromFitCheck("", "Test description")
    delay(500)

    val state1 = viewModel.uiState.first()
    createTestItem(state1.postUuid)

    viewModel.publishPost()
    delay(500)

    val finalState1 = viewModel.uiState.first()
    assertFalse(finalState1.isPublished)
    assertNotNull(finalState1.errorMessage)
    assertTrue(finalState1.errorMessage!!.contains("Missing required post data"))

    viewModel.clearErrorMessage()
    val stateNullMessage = viewModel.uiState.first()
    assertNull(stateNullMessage.errorMessage)

    delay(100)

    val viewModel2 = OutfitPreviewViewModel(itemsRepository, postRepository)
    viewModel2.publishPost()
    delay(500)

    val finalState2 = viewModel2.uiState.first()
    assertFalse(finalState2.isPublished)
    assertNotNull(finalState2.errorMessage)
    assertTrue(finalState2.errorMessage!!.contains("Missing required post data"))
  }

  @Test
  fun publishPost_withNoItems_stillSucceeds() = runBlocking {
    val imageUri = createReadableUri()
    val description = "Outfit with no items"

    viewModel.initFromFitCheck(imageUri.toString(), description)
    delay(500)

    viewModel.publishPost()
    delay(3000)

    val finalState = viewModel.uiState.first()
    assertTrue(finalState.isPublished)
    assertEquals("Post created successfully!", finalState.successMessage)

    val savedPost = postRepository.getPostById(finalState.postUuid)
    assertNotNull(savedPost)
    assertEquals(0, savedPost!!.itemsID.size)
  }

  @Test
  fun initFromFitCheck_andLoadItems_handlesInitializationCorrectly() = runBlocking {
    viewModel.loadItemsForPost()
    delay(500)

    val stateBeforeInit = viewModel.uiState.first()
    assertEquals(0, stateBeforeInit.items.size)
    assertTrue(stateBeforeInit.postUuid.isEmpty())

    val imageUri = createReadableUri()
    val description = "Init test"

    viewModel.initFromFitCheck(imageUri.toString(), description)
    delay(500)

    val stateAfterInit = viewModel.uiState.first()
    assertTrue(stateAfterInit.postUuid.isNotEmpty())
    assertEquals(imageUri.toString(), stateAfterInit.imageUri)
    assertEquals(description, stateAfterInit.description)
    assertEquals(0, stateAfterInit.items.size)

    val postUuid = stateAfterInit.postUuid
    createTestItem(postUuid)

    viewModel.loadItemsForPost()
    delay(500)

    val stateWithItems = viewModel.uiState.first()
    assertEquals(1, stateWithItems.items.size)
  }
}
