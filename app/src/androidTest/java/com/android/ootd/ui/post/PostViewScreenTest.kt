package com.android.ootd.ui.post

import android.content.ClipData
import android.content.ClipboardManager
import android.content.Context
import androidx.activity.ComponentActivity
import androidx.compose.ui.test.assertCountEquals
import androidx.compose.ui.test.assertIsDisplayed
import androidx.compose.ui.test.assertTextContains
import androidx.compose.ui.test.hasTestTag
import androidx.compose.ui.test.junit4.createAndroidComposeRule
import androidx.compose.ui.test.onAllNodesWithTag
import androidx.compose.ui.test.onNodeWithTag
import androidx.compose.ui.test.onNodeWithText
import androidx.compose.ui.test.performClick
import androidx.compose.ui.test.performScrollTo
import androidx.compose.ui.test.performScrollToNode
import androidx.compose.ui.test.performTextClearance
import androidx.compose.ui.test.performTextInput
import androidx.test.core.app.ApplicationProvider
import androidx.test.ext.junit.runners.AndroidJUnit4
import com.android.ootd.model.account.AccountRepository
import com.android.ootd.model.authentication.AccountService
import com.android.ootd.model.items.ImageData
import com.android.ootd.model.items.Item
import com.android.ootd.model.items.ItemsRepository
import com.android.ootd.model.items.Material
import com.android.ootd.model.post.OutfitPostRepository
import com.android.ootd.model.posts.Comment
import com.android.ootd.model.posts.Like
import com.android.ootd.model.posts.LikesRepository
import com.android.ootd.model.posts.OutfitPost
import com.android.ootd.model.user.User
import com.android.ootd.model.user.UserRepository
import com.android.ootd.ui.comments.CommentScreenTestTags
import com.android.ootd.ui.post.items.ItemsTestTags
import com.android.ootd.ui.theme.OOTDTheme
import io.mockk.clearAllMocks
import io.mockk.coEvery
import io.mockk.coVerify
import io.mockk.every
import io.mockk.mockk
import junit.framework.TestCase.assertEquals
import kotlinx.coroutines.test.runTest
import org.junit.After
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith

// DISCLAIMER: These tests were partly generated by AI and verified by human

@RunWith(AndroidJUnit4::class)
class PostViewScreenTest {

  @get:Rule val composeTestRule = createAndroidComposeRule<ComponentActivity>()

  private lateinit var mockPostRepository: OutfitPostRepository
  private lateinit var mockUserRepo: UserRepository
  private lateinit var mockLikesRepo: LikesRepository
  private lateinit var mockAccountService: AccountService
  private lateinit var mockItemsRepo: ItemsRepository
  private lateinit var mockAccountRepo: AccountRepository

  private lateinit var viewModel: PostViewViewModel
  private var onBackCalled = false

  private val testPost =
      OutfitPost(
          postUID = "test-post-id",
          name = "Test User",
          ownerId = "test-owner-id",
          userProfilePicURL = "https://example.com/profile.jpg",
          outfitURL = "https://example.com/outfit.jpg",
          description = "Test outfit description",
          itemsID = listOf("item1", "item2"),
          timestamp = System.currentTimeMillis())

  private val ownerUser =
      User(
          uid = "test-owner-id",
          username = "Owner Name",
          profilePicture = "https://example.com/pfp.jpg")

  private val testItem1 =
      Item(
          itemUuid = "item1",
          postUuids = listOf("test-post-id"),
          image = ImageData("img1", "https://example.com/img1.jpg"),
          category = "Clothing",
          type = "T-Shirt",
          brand = "Nike",
          price = 29.99,
          material = listOf(Material("Cotton", 100.0)),
          link = "https://example.com/tshirt",
          ownerId = "test-owner-id",
          condition = "Like new",
          size = "M",
          fitType = "Regular",
          style = "Casual",
          notes = "Made by grandma")

  private val testItem2 =
      Item(
          itemUuid = "item2",
          postUuids = listOf("test-post-id"),
          image = ImageData("img2", "https://example.com/img2.jpg"),
          category = "Shoes",
          type = "Sneakers",
          brand = "Adidas",
          price = 89.99,
          material = listOf(Material("Leather", 80.0), Material("Rubber", 20.0)),
          link = "https://example.com/sneakers",
          ownerId = "test-owner-id",
          condition = "Used",
          size = "42",
          fitType = "Slim",
          style = "Sporty",
          notes = "Limited edition")

  @Before
  fun setup() {
    mockPostRepository = mockk(relaxed = true)
    mockUserRepo = mockk(relaxed = true)
    mockLikesRepo = mockk(relaxed = true)
    mockAccountService = mockk(relaxed = true)
    mockItemsRepo = mockk(relaxed = true)
    mockAccountRepo = mockk(relaxed = true)

    coEvery { mockUserRepo.getUser(any()) } returns
        User(uid = "placeholder", username = "placeholder", profilePicture = "")

    coEvery { mockLikesRepo.getLikesForPost(any()) } returns emptyList()
    coEvery { mockItemsRepo.getFriendItemsForPost(any(), any()) } returns emptyList()
    coEvery { mockAccountRepo.getStarredItems(any()) } returns emptyList()

    onBackCalled = false

    every { mockAccountService.currentUserId } returns "test-owner-id"
  }

  @After
  fun tearDown() {
    clearAllMocks()
  }

  private fun setContent(
      postId: String,
      onProfileClick: (String) -> Unit = {},
      onEditItem: (String) -> Unit = {}
  ) {
    viewModel =
        PostViewViewModel(
            postId,
            mockPostRepository,
            mockUserRepo,
            mockLikesRepo,
            mockAccountService,
            mockItemsRepo,
            mockAccountRepo)

    composeTestRule.setContent {
      OOTDTheme {
        PostViewScreen(
            postId = postId,
            onBack = { onBackCalled = true },
            onProfileClick = onProfileClick,
            onEditItem = onEditItem,
            viewModel = viewModel)
      }
    }
    composeTestRule.waitForIdle()
  }

  /**
   * Helper function to scroll to the interaction row (like/comment buttons) since it may be below
   * the fold on CI emulator
   */
  private fun scrollToInteractionRow() {
    try {
      composeTestRule
          .onNodeWithTag(PostViewTestTags.SCREEN)
          .performScrollToNode(hasTestTag(PostViewTestTags.LIKE_ROW))
      composeTestRule.waitForIdle()
    } catch (e: Exception) {
      // Already visible, continue
    }
  }

  /**
   * Helper function to scroll to the items section since it's below the fold on CI emulator Tests
   * will pass locally without this, but fail on CI without scrolling first.
   */
  private fun scrollToItemsSection() {
    try {
      composeTestRule
          .onNodeWithTag(PostViewTestTags.SCREEN)
          .performScrollToNode(hasTestTag(PostViewTestTags.ITEMS_SECTION))
      composeTestRule.waitForIdle()
    } catch (e: Exception) {
      // Items section might not exist or already visible, continue
    }
  }

  @Test
  fun screen_displays_post_image_when_loaded_successfully() = runTest {
    coEvery { mockPostRepository.getPostById("test-post-id") } returns testPost
    coEvery { mockUserRepo.getUser(any()) } returns ownerUser
    coEvery { mockLikesRepo.getLikesForPost(any()) } returns emptyList()
    coEvery { mockItemsRepo.getFriendItemsForPost("test-post-id", "test-owner-id") } returns
        listOf(testItem1, testItem2)

    setContent("test-post-id")
    composeTestRule.waitForIdle()

    composeTestRule.onNodeWithTag(PostViewTestTags.POST_IMAGE).assertIsDisplayed()
  }

  @Test
  fun screen_displays_error_message_when_repository_throws_exception() = runTest {
    coEvery { mockPostRepository.getPostById("test-post-id") } throws Exception("Network error")

    setContent("test-post-id")
    composeTestRule.waitForIdle()
    composeTestRule.onNodeWithTag(PostViewTestTags.SCREEN).assertExists()
  }

  @Test
  fun clicking_edit_shows_textfield_and_counter() = runTest {
    coEvery { mockPostRepository.getPostById(any()) } returns testPost
    coEvery { mockUserRepo.getUser(any()) } returns ownerUser
    coEvery { mockLikesRepo.getLikesForPost(any()) } returns emptyList()
    coEvery { mockItemsRepo.getFriendItemsForPost(any(), any()) } returns emptyList()

    setContent("test-post-id")
    composeTestRule.waitForIdle()

    composeTestRule
        .onNodeWithTag(PostViewTestTags.DROPDOWN_OPTIONS_MENU)
        .performScrollTo()
        .assertIsDisplayed()
        .assertExists()

    // Open dropdown
    composeTestRule.onNodeWithTag(PostViewTestTags.DROPDOWN_OPTIONS_MENU).performClick()
    composeTestRule.waitForIdle()

    composeTestRule.onNodeWithTag(PostViewTestTags.EDIT_DESCRIPTION_OPTION).assertIsDisplayed()

    // Click edit
    composeTestRule.onNodeWithTag(PostViewTestTags.EDIT_DESCRIPTION_OPTION).performClick()
    composeTestRule.waitForIdle()

    // TextField appears = edit mode active
    composeTestRule
        .onNodeWithTag(PostViewTestTags.EDIT_DESCRIPTION_FIELD)
        .performScrollTo()
        .assertIsDisplayed()
        .assertExists()
    composeTestRule.waitForIdle()

    // Counter appears = edit mode active
    composeTestRule.onNodeWithTag(PostViewTestTags.DESCRIPTION_COUNTER).assertExists()
  }

  @Test
  fun three_dots_icon_and_options_invisible_for_non_owner() = runTest {
    coEvery { mockPostRepository.getPostById(any()) } returns testPost
    coEvery { mockUserRepo.getUser(any()) } returns ownerUser
    coEvery { mockLikesRepo.getLikesForPost(any()) } returns emptyList()
    coEvery { mockItemsRepo.getFriendItemsForPost(any(), any()) } returns emptyList()
    every { mockAccountService.currentUserId } returns "some-other-user-id"

    setContent("test-post-id")
    composeTestRule.waitForIdle()

    composeTestRule.onNodeWithTag(PostViewTestTags.DROPDOWN_OPTIONS_MENU).assertDoesNotExist()
    composeTestRule.onNodeWithTag(PostViewTestTags.EDIT_DESCRIPTION_OPTION).assertDoesNotExist()
    composeTestRule.onNodeWithTag(PostViewTestTags.DELETE_POST_OPTION).assertDoesNotExist()
    composeTestRule.onNodeWithTag(PostViewTestTags.EDIT_DESCRIPTION_FIELD).assertDoesNotExist()
    composeTestRule.onNodeWithTag(PostViewTestTags.DESCRIPTION_COUNTER).assertDoesNotExist()
  }

  @Test
  fun description_stays_same_after_edit_cancel() = runTest {
    coEvery { mockPostRepository.getPostById(any()) } returns testPost
    coEvery { mockUserRepo.getUser(any()) } returns ownerUser
    coEvery { mockLikesRepo.getLikesForPost(any()) } returns emptyList()
    coEvery { mockItemsRepo.getFriendItemsForPost(any(), any()) } returns emptyList()

    val original = testPost.description
    val modified = "Modified description text"

    setContent("test-post-id")
    composeTestRule.waitForIdle()

    // Open edit mode
    composeTestRule
        .onNodeWithTag(PostViewTestTags.DROPDOWN_OPTIONS_MENU)
        .performScrollTo()
        .performClick()
    composeTestRule.waitForIdle()
    composeTestRule.onNodeWithTag(PostViewTestTags.EDIT_DESCRIPTION_OPTION).performClick()
    composeTestRule.waitForIdle()

    // Ensure edit field visible with original text
    composeTestRule
        .onNodeWithTag(PostViewTestTags.EDIT_DESCRIPTION_FIELD)
        .performScrollTo()
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(PostViewTestTags.EDIT_DESCRIPTION_FIELD)
        .assertTextContains(original)

    // Modify the description text
    composeTestRule.onNodeWithTag(PostViewTestTags.EDIT_DESCRIPTION_FIELD).performTextClearance()
    composeTestRule
        .onNodeWithTag(PostViewTestTags.EDIT_DESCRIPTION_FIELD)
        .performTextInput(modified)
    composeTestRule.waitForIdle()
    composeTestRule
        .onNodeWithTag(PostViewTestTags.EDIT_DESCRIPTION_FIELD)
        .assertTextContains(modified)

    // Cancel edit
    composeTestRule.onNodeWithTag(PostViewTestTags.CANCEL_EDITING_BUTTON).performClick()
    composeTestRule.waitForIdle()

    // Ensure screen shows original description and not the modified one
    composeTestRule.onNodeWithText(original, substring = true).assertExists().assertIsDisplayed()
    composeTestRule.onNodeWithText(modified, substring = true).assertDoesNotExist()

    // Re-open edit
    composeTestRule.onNodeWithTag(PostViewTestTags.DROPDOWN_OPTIONS_MENU).performClick()
    composeTestRule.waitForIdle()
    composeTestRule.onNodeWithTag(PostViewTestTags.EDIT_DESCRIPTION_OPTION).performClick()
    composeTestRule.waitForIdle()

    // TextField should contain the original description again
    composeTestRule
        .onNodeWithTag(PostViewTestTags.EDIT_DESCRIPTION_FIELD)
        .performScrollTo()
        .assertExists()
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(PostViewTestTags.EDIT_DESCRIPTION_FIELD)
        .assertTextContains(original)
    composeTestRule.onNodeWithText(modified, substring = true).assertDoesNotExist()
  }

  // Items section tests
  @Test
  fun owner_items_complete_flow() = runTest {
    var editedItemId = ""

    coEvery { mockPostRepository.getPostById("test-post-id") } returns testPost
    coEvery { mockUserRepo.getUser(any()) } returns ownerUser
    coEvery { mockLikesRepo.getLikesForPost(any()) } returns emptyList()
    coEvery { mockItemsRepo.getFriendItemsForPost("test-post-id", "test-owner-id") } returns
        listOf(testItem1, testItem2)
    coEvery { mockAccountRepo.getStarredItems(any()) } returns emptyList()
    every { mockAccountService.currentUserId } returns "test-owner-id"

    setContent("test-post-id", onEditItem = { editedItemId = it })
    composeTestRule.waitForIdle()

    // Wait for items to load
    composeTestRule.waitUntil(timeoutMillis = 10_000) {
      composeTestRule
          .onAllNodesWithTag(ItemsTestTags.getTestTagForItem(testItem1))
          .fetchSemanticsNodes()
          .isNotEmpty()
    }

    scrollToItemsSection()
    composeTestRule.waitForIdle()

    // 1. Verify items section displays correctly with title
    composeTestRule.onNodeWithTag(PostViewTestTags.ITEMS_SECTION_TITLE).assertIsDisplayed()
    composeTestRule.onNodeWithText("FIT ITEMS").assertIsDisplayed()

    // 2. Verify items display in horizontal row (both items visible)
    composeTestRule.onNodeWithTag(ItemsTestTags.ITEMS_GRID).assertIsDisplayed()
    composeTestRule.onNodeWithTag(ItemsTestTags.getTestTagForItem(testItem1)).assertIsDisplayed()
    composeTestRule.onNodeWithTag(ItemsTestTags.getTestTagForItem(testItem2)).assertIsDisplayed()

    // 3. Verify owner sees edit buttons - should have 2
    composeTestRule.waitUntil(timeoutMillis = 5_000) {
      composeTestRule
          .onAllNodesWithTag(ItemsTestTags.ITEM_CARD_EDIT_BUTTON, useUnmergedTree = true)
          .fetchSemanticsNodes()
          .size >= 2
    }

    val editButtons =
        composeTestRule.onAllNodesWithTag(
            ItemsTestTags.ITEM_CARD_EDIT_BUTTON, useUnmergedTree = true)
    editButtons.assertCountEquals(2)

    composeTestRule
        .onAllNodesWithTag(ItemsTestTags.getStarButtonTag(testItem1))
        .assertCountEquals(0)
    composeTestRule
        .onAllNodesWithTag(ItemsTestTags.getStarButtonTag(testItem2))
        .assertCountEquals(0)

    // 4. Verify edit button triggers callback - click the first one
    editButtons[0].performClick()
    composeTestRule.waitForIdle()
    assertEquals("item1", editedItemId)

    // 5. Open item details dialog
    composeTestRule.onNodeWithTag(ItemsTestTags.getTestTagForItem(testItem1)).performClick()
    composeTestRule.waitUntil(timeoutMillis = 5_000) {
      composeTestRule
          .onAllNodesWithTag(ItemsTestTags.ITEM_DETAILS_DIALOG)
          .fetchSemanticsNodes()
          .isNotEmpty()
    }

    // 6. Verify all item information is displayed
    composeTestRule.onNodeWithTag(ItemsTestTags.ITEM_BRAND, useUnmergedTree = true).assertExists()
    composeTestRule.onNodeWithTag(ItemsTestTags.ITEM_PRICE, useUnmergedTree = true).assertExists()
    composeTestRule
        .onNodeWithTag(ItemsTestTags.ITEM_MATERIAL, useUnmergedTree = true)
        .assertExists()
    composeTestRule.onNodeWithTag(ItemsTestTags.ITEM_LINK, useUnmergedTree = true).assertExists()

    // Scroll to bottom fields
    composeTestRule
        .onNodeWithTag(ItemsTestTags.ITEM_DETAILS_DIALOG)
        .performScrollToNode(hasTestTag(ItemsTestTags.ITEM_NOTES))
    composeTestRule.onNodeWithTag(ItemsTestTags.ITEM_NOTES, useUnmergedTree = true).assertExists()

    // 7. Test copy buttons work
    val clipboard =
        ApplicationProvider.getApplicationContext<Context>()
            .getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager
    clipboard.setPrimaryClip(ClipData.newPlainText("", ""))

    composeTestRule
        .onNodeWithTag(ItemsTestTags.ITEM_DETAILS_DIALOG)
        .performScrollToNode(hasTestTag(ItemsTestTags.ITEM_NOTES_COPY))
    composeTestRule
        .onNodeWithTag(ItemsTestTags.ITEM_NOTES_COPY, useUnmergedTree = true)
        .performClick()
    composeTestRule.waitForIdle()
    composeTestRule.runOnIdle {
      assertEquals("Made by grandma", clipboard.primaryClip?.getItemAt(0)?.text?.toString() ?: "")
    }

    composeTestRule
        .onNodeWithTag(ItemsTestTags.ITEM_DETAILS_DIALOG)
        .performScrollToNode(hasTestTag(ItemsTestTags.ITEM_LINK_COPY))
    composeTestRule
        .onNodeWithTag(ItemsTestTags.ITEM_LINK_COPY, useUnmergedTree = true)
        .performClick()
    composeTestRule.waitForIdle()
    composeTestRule.runOnIdle {
      assertEquals(
          "https://example.com/tshirt", clipboard.primaryClip?.getItemAt(0)?.text?.toString() ?: "")
    }
  }

  @Test
  fun nonOwner_items_complete_flow() = runTest {
    coEvery { mockPostRepository.getPostById("test-post-id") } returns testPost
    coEvery { mockUserRepo.getUser(any()) } returns ownerUser
    coEvery { mockLikesRepo.getLikesForPost(any()) } returns emptyList()
    coEvery { mockItemsRepo.getFriendItemsForPost("test-post-id", "test-owner-id") } returns
        listOf(testItem1, testItem2)
    every { mockAccountService.currentUserId } returns "different-user-id"
    coEvery { mockAccountRepo.getStarredItems(any()) } returns emptyList()
    coEvery { mockAccountRepo.toggleStarredItem("item1") } returns listOf("item1")

    setContent("test-post-id")
    composeTestRule.waitForIdle()
    scrollToItemsSection()

    // 1. Verify items section displays correctly
    composeTestRule.onNodeWithTag(PostViewTestTags.ITEMS_SECTION_TITLE).assertIsDisplayed()
    composeTestRule.onNodeWithTag(ItemsTestTags.ITEMS_GRID).assertIsDisplayed()
    composeTestRule.onNodeWithTag(ItemsTestTags.getTestTagForItem(testItem1)).assertIsDisplayed()

    // 2. Verify non-owner sees star button (not edit button)
    composeTestRule.onNodeWithTag(ItemsTestTags.getStarButtonTag(testItem1)).assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(ItemsTestTags.ITEM_CARD_EDIT_BUTTON, useUnmergedTree = true)
        .assertDoesNotExist()

    // 3. Verify star button toggles correctly
    composeTestRule.onNodeWithTag(ItemsTestTags.getStarButtonTag(testItem1)).performClick()
    composeTestRule.waitForIdle()
    coVerify { mockAccountRepo.toggleStarredItem("item1") }

    // 4. Open item details dialog
    composeTestRule.onNodeWithTag(ItemsTestTags.getTestTagForItem(testItem1)).performClick()
    composeTestRule.waitUntil(timeoutMillis = 5_000) {
      composeTestRule
          .onAllNodesWithTag(ItemsTestTags.ITEM_DETAILS_DIALOG)
          .fetchSemanticsNodes()
          .isNotEmpty()
    }

    // 5. Verify dialog displays item information
    composeTestRule.onNodeWithTag(ItemsTestTags.ITEM_DETAILS_DIALOG).assertIsDisplayed()
    composeTestRule.onNodeWithTag(ItemsTestTags.ITEM_BRAND, useUnmergedTree = true).assertExists()
    composeTestRule.onNodeWithTag(ItemsTestTags.ITEM_PRICE, useUnmergedTree = true).assertExists()
    composeTestRule.onNodeWithTag(ItemsTestTags.ITEM_LINK, useUnmergedTree = true).assertExists()
  }

  @Test
  fun itemsSection_shows_empty_state_when_no_items() = runTest {
    coEvery { mockPostRepository.getPostById("test-post-id") } returns testPost
    coEvery { mockUserRepo.getUser(any()) } returns ownerUser
    coEvery { mockLikesRepo.getLikesForPost(any()) } returns emptyList()
    coEvery { mockItemsRepo.getFriendItemsForPost("test-post-id", "test-owner-id") } returns
        emptyList()

    setContent("test-post-id")
    composeTestRule.waitForIdle()
    scrollToItemsSection()

    composeTestRule.onNodeWithText("No items associated with this post.").assertIsDisplayed()
  }

  @Test
  fun itemsSection_shows_loading_when_items_loading() = runTest {
    coEvery { mockPostRepository.getPostById("test-post-id") } returns testPost
    coEvery { mockUserRepo.getUser(any()) } returns ownerUser
    coEvery { mockLikesRepo.getLikesForPost(any()) } returns emptyList()
    coEvery { mockItemsRepo.getFriendItemsForPost(any(), any()) } coAnswers
        {
          kotlinx.coroutines.delay(2000)
          listOf(testItem1)
        }
    coEvery { mockAccountRepo.getStarredItems(any()) } returns emptyList()

    setContent("test-post-id")
    composeTestRule.onNodeWithTag(PostViewTestTags.LOADING_INDICATOR).assertIsDisplayed()
    composeTestRule.waitForIdle()
  }

  @Test
  fun multiple_items_display_correctly_in_horizontal_scroll() = runTest {
    val manyItems =
        (1..5).map { index ->
          Item(
              itemUuid = "item-$index",
              postUuids = listOf("test-post-id"),
              image = ImageData("img$index", "https://example.com/img$index.jpg"),
              category = "Category $index",
              type = "Type $index",
              brand = "Brand $index",
              price = index * 10.0,
              material = emptyList(),
              link = "https://example.com/item$index",
              ownerId = "test-owner-id")
        }

    coEvery { mockPostRepository.getPostById("test-post-id") } returns testPost
    coEvery { mockUserRepo.getUser(any()) } returns ownerUser
    coEvery { mockLikesRepo.getLikesForPost(any()) } returns emptyList()
    coEvery { mockItemsRepo.getFriendItemsForPost("test-post-id", "test-owner-id") } returns
        manyItems

    setContent("test-post-id")
    composeTestRule.waitForIdle()
    scrollToItemsSection()

    composeTestRule.onNodeWithTag(ItemsTestTags.ITEMS_GRID).assertIsDisplayed()
    composeTestRule.onNodeWithTag(ItemsTestTags.getTestTagForItem(manyItems[0])).assertIsDisplayed()
  }

  @Test
  fun comment_button_shows_zero_comments() = runTest {
    coEvery { mockPostRepository.getPostById("test-post-id") } returns testPost
    coEvery { mockUserRepo.getUser(any()) } returns ownerUser
    coEvery { mockLikesRepo.getLikesForPost(any()) } returns emptyList()
    coEvery { mockItemsRepo.getFriendItemsForPost(any(), any()) } returns emptyList()

    setContent("test-post-id")
    composeTestRule.waitForIdle()
    scrollToInteractionRow()

    composeTestRule.waitForIdle()
    composeTestRule.onNodeWithTag(PostViewTestTags.COMMENT_BUTTON).assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(PostViewTestTags.COMMENT_COUNT, useUnmergedTree = true)
        .assertTextContains("0 comments")
  }

  @Test
  fun comment_button_opens_comment_bottom_sheet() = runTest {
    coEvery { mockPostRepository.getPostById("test-post-id") } returns testPost
    coEvery { mockUserRepo.getUser(any()) } returns ownerUser
    coEvery { mockLikesRepo.getLikesForPost(any()) } returns emptyList()
    coEvery { mockItemsRepo.getFriendItemsForPost(any(), any()) } returns emptyList()

    setContent("test-post-id")
    composeTestRule.waitForIdle()
    scrollToInteractionRow()

    // Click the comment button
    composeTestRule.onNodeWithTag(PostViewTestTags.COMMENT_BUTTON).performClick()
    composeTestRule.waitForIdle()

    // Verify the comment bottom sheet is displayed
    composeTestRule.onNodeWithTag(CommentScreenTestTags.COMMENT_BOTTOM_SHEET).assertIsDisplayed()
  }

  @Test
  fun like_and_comment_buttons_display_together() = runTest {
    val postWithLikesAndComments =
        testPost.copy(
            comments =
                listOf(
                    Comment(
                        commentId = "comment1",
                        ownerId = "user1",
                        text = "Nice!",
                        timestamp = System.currentTimeMillis())))

    coEvery { mockPostRepository.getPostById("test-post-id") } returns postWithLikesAndComments
    coEvery { mockUserRepo.getUser(any()) } returns ownerUser
    coEvery { mockLikesRepo.getLikesForPost(any()) } returns
        listOf(
            Like(
                postId = "test-post-id",
                postLikerId = "test-owner-id",
                timestamp = System.currentTimeMillis()))
    coEvery { mockItemsRepo.getFriendItemsForPost(any(), any()) } returns emptyList()

    setContent("test-post-id")
    composeTestRule.waitForIdle()
    scrollToInteractionRow()

    // Verify both like and comment buttons are visible
    composeTestRule.onNodeWithTag(PostViewTestTags.LIKE_ROW).assertIsDisplayed()
    composeTestRule.onNodeWithTag(PostViewTestTags.COMMENT_BUTTON).assertIsDisplayed()

    // Verify they show correct counts
    composeTestRule
        .onNodeWithTag(PostViewTestTags.COMMENT_COUNT, useUnmergedTree = true)
        .assertIsDisplayed()
        .assertTextContains("1 comment")
  }

  @Test
  fun location_icon_click_triggers_callback() = runTest {
    var locationClickCalled = false
    var clickedLocation: com.android.ootd.model.map.Location? = null

    val testLocation = com.android.ootd.model.map.Location(46.5197, 6.6323, "EPFL")
    val postWithLocation = testPost.copy(location = testLocation)

    coEvery { mockPostRepository.getPostById("test-post-id") } returns postWithLocation
    coEvery { mockUserRepo.getUser(any()) } returns ownerUser
    coEvery { mockLikesRepo.getLikesForPost(any()) } returns emptyList()
    coEvery { mockItemsRepo.getFriendItemsForPost("test-post-id", "test-owner-id") } returns
        emptyList()

    viewModel =
        PostViewViewModel(
            "test-post-id",
            mockPostRepository,
            mockUserRepo,
            mockLikesRepo,
            mockAccountService,
            mockItemsRepo,
            mockAccountRepo)

    composeTestRule.setContent {
      OOTDTheme {
        PostViewScreen(
            postId = "test-post-id",
            onBack = { onBackCalled = true },
            onLocationClick = { location ->
              locationClickCalled = true
              clickedLocation = location
            },
            viewModel = viewModel)
      }
    }
    composeTestRule.waitForIdle()

    // Click on the location icon
    composeTestRule.onNodeWithTag(PostViewTestTags.LOCATION_ICON).performClick()

    assertEquals(true, locationClickCalled)
    assertEquals(testLocation, clickedLocation)
  }
}
