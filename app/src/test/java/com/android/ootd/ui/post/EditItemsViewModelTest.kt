package com.android.ootd.ui.post

import android.content.Context
import android.net.Uri
import androidx.test.core.app.ApplicationProvider
import com.android.ootd.model.Item
import com.android.ootd.model.ItemsRepository
import com.android.ootd.model.Material
import io.mockk.coEvery
import io.mockk.coVerify
import io.mockk.every
import io.mockk.mockk
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.StandardTestDispatcher
import kotlinx.coroutines.test.advanceUntilIdle
import kotlinx.coroutines.test.resetMain
import kotlinx.coroutines.test.runTest
import kotlinx.coroutines.test.setMain
import org.junit.After
import org.junit.Assert.assertEquals
import org.junit.Assert.assertFalse
import org.junit.Assert.assertNull
import org.junit.Assert.assertTrue
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.robolectric.RobolectricTestRunner

// Test partially generated by the AI coding agent: Claude Sonnet 4.5
@OptIn(ExperimentalCoroutinesApi::class)
@RunWith(RobolectricTestRunner::class)
class EditItemsViewModelTest {

  private lateinit var viewModel: EditItemsViewModel
  private lateinit var mockRepository: ItemsRepository
  private val testDispatcher = StandardTestDispatcher()

  @Before
  fun setup() {
    Dispatchers.setMain(testDispatcher)
    mockRepository = mockk(relaxed = true)
    viewModel = EditItemsViewModel(mockRepository)
  }

  @After
  fun tearDown() {
    Dispatchers.resetMain()
  }

  @Test
  fun `initial state is correct`() {
    val state = viewModel.uiState.value
    assertEquals("", state.itemId)
    assertEquals(Uri.EMPTY, state.image)
    assertEquals("", state.category)
    assertEquals("", state.type)
    assertEquals("", state.brand)
    assertEquals(0.0, state.price, 0.0)
    assertEquals(emptyList<Material>(), state.material)
    assertEquals("", state.link)
    assertNull(state.errorMessage)
    assertNull(state.invalidPhotoMsg)
    assertNull(state.invalidCategory)
    assertEquals(emptyList<String>(), state.suggestions)
  }

  @Test
  fun `isEditValid returns true when all required fields are valid`() {
    val mockUri = mockk<Uri>()
    every { mockUri.toString() } returns "content://test"

    viewModel.setPhoto(mockUri)
    viewModel.setCategory("Clothing")

    val state = viewModel.uiState.value
    assertTrue(state.isEditValid)
  }

  @Test
  fun `isEditValid returns false when image is empty`() {
    viewModel.setCategory("Clothing")

    val state = viewModel.uiState.value
    assertFalse(state.isEditValid)
  }

  @Test
  fun `isEditValid returns false when category is empty`() {
    val mockUri = mockk<Uri>()
    every { mockUri.toString() } returns "content://test"
    viewModel.setPhoto(mockUri)

    val state = viewModel.uiState.value
    assertFalse(state.isEditValid)
  }

  @Test
  fun `setPhoto updates image in state`() {
    val mockUri = mockk<Uri>()
    every { mockUri.toString() } returns "content://test"

    viewModel.setPhoto(mockUri)

    val state = viewModel.uiState.value
    assertEquals(mockUri, state.image)
    assertNull(state.invalidPhotoMsg)
  }

  @Test
  fun `setPhoto with Uri EMPTY sets error message`() {
    viewModel.setPhoto(Uri.EMPTY)

    val state = viewModel.uiState.value
    assertEquals(Uri.EMPTY, state.image)
    assertEquals("Please select a photo.", state.invalidPhotoMsg)
  }

  @Test
  fun `setCategory updates category in state`() {
    viewModel.setCategory("Clothing")

    val state = viewModel.uiState.value
    assertEquals("Clothing", state.category)
    assertNull(state.invalidCategory)
  }

  @Test
  fun `setCategory with empty string sets error message`() {
    viewModel.setCategory("")

    val state = viewModel.uiState.value
    assertEquals("", state.category)
    assertEquals("Please select a category.", state.invalidCategory)
  }

  @Test
  fun `setType updates type in state`() {
    viewModel.setType("T-shirt")

    val state = viewModel.uiState.value
    assertEquals("T-shirt", state.type)
  }

  @Test
  fun `setBrand updates brand in state`() {
    viewModel.setBrand("Nike")

    val state = viewModel.uiState.value
    assertEquals("Nike", state.brand)
  }

  @Test
  fun `setPrice updates price in state`() {
    viewModel.setPrice(49.99)

    val state = viewModel.uiState.value
    assertEquals(49.99, state.price, 0.0)
  }

  @Test
  fun `setMaterial updates material in state`() {
    val materials = listOf(Material("Cotton", 100.0))
    viewModel.setMaterial(materials)

    val state = viewModel.uiState.value
    assertEquals(materials, state.material)
  }

  @Test
  fun `setLink updates link in state`() {
    viewModel.setLink("https://example.com")

    val state = viewModel.uiState.value
    assertEquals("https://example.com", state.link)
  }

  @Test
  fun `setErrorMsg updates error message`() {
    viewModel.setErrorMsg("Test error")

    val state = viewModel.uiState.value
    assertEquals("Test error", state.errorMessage)
  }

  @Test
  fun `clearErrorMsg clears error message`() {
    viewModel.setErrorMsg("Test error")
    viewModel.clearErrorMsg()

    val state = viewModel.uiState.value
    assertNull(state.errorMessage)
  }

  @Test
  fun `loadItem populates state with item data`() {
    val mockUri = mockk<Uri>()
    every { mockUri.toString() } returns "content://test"
    val materials = listOf(Material("Cotton", 100.0))
    val item =
        Item(
            uuid = "test-id",
            image = mockUri,
            category = "Clothing",
            type = "T-shirt",
            brand = "Nike",
            price = 49.99,
            material = materials,
            link = "https://example.com")

    viewModel.loadItem(item)

    val state = viewModel.uiState.value
    assertEquals("test-id", state.itemId)
    assertEquals(mockUri, state.image)
    assertEquals("Clothing", state.category)
    assertEquals("T-shirt", state.type)
    assertEquals("Nike", state.brand)
    assertEquals(49.99, state.price, 0.0)
    assertEquals(materials, state.material)
    assertEquals("https://example.com", state.link)
  }

  @Test
  fun `loadItem handles null optional values`() {
    val mockUri = mockk<Uri>()
    every { mockUri.toString() } returns "content://test"
    val item =
        Item(
            uuid = "test-id",
            image = mockUri,
            category = "Clothing",
            type = null,
            brand = null,
            price = null,
            material = emptyList(),
            link = null)

    viewModel.loadItem(item)

    val state = viewModel.uiState.value
    assertEquals("test-id", state.itemId)
    assertEquals(mockUri, state.image)
    assertEquals("Clothing", state.category)
    assertEquals("", state.type)
    assertEquals("", state.brand)
    assertEquals(0.0, state.price, 0.0)
    assertEquals("", state.link)
  }

  @Test
  fun `canEditItems returns false when validation fails`() {
    val result = viewModel.canEditItems()

    assertFalse(result)
    val state = viewModel.uiState.value
    assertEquals("Please fill in all required fields.", state.errorMessage)
  }

  @Test
  fun `canEditItems returns false when URL is invalid`() {
    val mockUri = mockk<Uri>()
    every { mockUri.toString() } returns "content://test"

    viewModel.setPhoto(mockUri)
    viewModel.setCategory("Clothing")
    viewModel.setLink("invalid-url")

    val result = viewModel.canEditItems()

    assertFalse(result)
    val state = viewModel.uiState.value
    assertEquals("Please enter a valid URL.", state.errorMessage)
  }

  @Test
  fun `canEditItems returns true and calls repository when valid`() = runTest {
    val mockUri = mockk<Uri>()
    every { mockUri.toString() } returns "content://test"

    coEvery { mockRepository.editItem(any(), any()) } returns Unit

    // Load an item first to set itemId
    viewModel.loadItem(
        Item(
            uuid = "test-id",
            image = mockUri,
            category = "Clothing",
            type = "T-shirt",
            brand = "Nike",
            price = 49.99,
            material = emptyList(),
            link = "https://example.com"))

    val result = viewModel.canEditItems()

    advanceUntilIdle()

    assertTrue(result)
    coVerify { mockRepository.editItem(any(), any()) }
  }

  @Test
  fun `canEditItems allows empty link`() = runTest {
    val mockUri = mockk<Uri>()
    every { mockUri.toString() } returns "content://test"

    coEvery { mockRepository.editItem(any(), any()) } returns Unit

    viewModel.loadItem(
        Item(
            uuid = "test-id",
            image = mockUri,
            category = "Clothing",
            type = "T-shirt",
            brand = "Nike",
            price = 49.99,
            material = emptyList(),
            link = ""))

    val result = viewModel.canEditItems()

    advanceUntilIdle()

    assertTrue(result)
  }

  @Test
  fun `editItemsInRepository calls repository editItem`() = runTest {
    val mockUri = mockk<Uri>()
    every { mockUri.toString() } returns "content://test"

    coEvery { mockRepository.editItem(any(), any()) } returns Unit

    val item =
        Item(
            uuid = "test-id",
            image = mockUri,
            category = "Clothing",
            type = "T-shirt",
            brand = "Nike",
            price = 49.99,
            material = emptyList(),
            link = "https://example.com")

    viewModel.editItemsInRepository(item)

    advanceUntilIdle()

    coVerify { mockRepository.editItem("test-id", item) }
    val state = viewModel.uiState.value
    assertEquals("Item updated successfully!", state.errorMessage)
  }

  @Test
  fun `editItemsInRepository handles exception`() = runTest {
    val mockUri = mockk<Uri>()
    every { mockUri.toString() } returns "content://test"

    coEvery { mockRepository.editItem(any(), any()) } throws Exception("Update failed")

    val item =
        Item(
            uuid = "test-id",
            image = mockUri,
            category = "Clothing",
            type = "T-shirt",
            brand = "Nike",
            price = 49.99,
            material = emptyList(),
            link = "https://example.com")

    viewModel.editItemsInRepository(item)

    advanceUntilIdle()

    val state = viewModel.uiState.value
    assertEquals("Failed to update item: Update failed", state.errorMessage)
  }

  @Test
  fun `deleteItem calls repository when itemId is not empty`() = runTest {
    val mockUri = mockk<Uri>()
    every { mockUri.toString() } returns "content://test"
    coEvery { mockRepository.deleteItem(any()) } returns Unit

    viewModel.loadItem(
        Item(
            uuid = "test-id",
            image = mockUri,
            category = "Clothing",
            type = null,
            brand = null,
            price = null,
            material = emptyList(),
            link = null))
    viewModel.deleteItem()

    advanceUntilIdle()

    coVerify { mockRepository.deleteItem("test-id") }
    val state = viewModel.uiState.value
    assertEquals("Item deleted successfully!", state.errorMessage)
  }

  @Test
  fun `deleteItem does not call repository when itemId is empty`() = runTest {
    viewModel.deleteItem()

    advanceUntilIdle()

    coVerify(exactly = 0) { mockRepository.deleteItem(any()) }
    val state = viewModel.uiState.value
    assertEquals("No item to delete.", state.errorMessage)
  }

  @Test
  fun `deleteItem handles exception`() = runTest {
    val mockUri = mockk<Uri>()
    every { mockUri.toString() } returns "content://test"
    coEvery { mockRepository.deleteItem(any()) } throws Exception("Delete failed")

    viewModel.loadItem(
        Item(
            uuid = "test-id",
            image = mockUri,
            category = "Clothing",
            type = null,
            brand = null,
            price = null,
            material = emptyList(),
            link = null))
    viewModel.deleteItem()

    advanceUntilIdle()

    val state = viewModel.uiState.value
    assertEquals("Failed to delete item: Delete failed", state.errorMessage)
  }

  @Test
  fun `initTypeSuggestions loads suggestions from context`() {
    val context = ApplicationProvider.getApplicationContext<Context>()

    viewModel.initTypeSuggestions(context)

    // After initialization, suggestions should be available
    viewModel.setCategory("Clothing")
    viewModel.updateTypeSuggestions("")

    val state = viewModel.uiState.value
    assertTrue(state.suggestions.isNotEmpty())
  }

  @Test
  fun `updateTypeSuggestions filters by input`() {
    val context = ApplicationProvider.getApplicationContext<Context>()
    viewModel.initTypeSuggestions(context)

    viewModel.setCategory("Clothing")
    viewModel.updateTypeSuggestions("T")

    val state = viewModel.uiState.value
    assertTrue(state.suggestions.all { it.startsWith("T", ignoreCase = true) })
  }

  @Test
  fun `updateTypeSuggestions returns all suggestions when input is blank`() {
    val context = ApplicationProvider.getApplicationContext<Context>()
    viewModel.initTypeSuggestions(context)

    viewModel.setCategory("Clothing")
    viewModel.updateTypeSuggestions("")

    val state = viewModel.uiState.value
    assertTrue(state.suggestions.isNotEmpty())
  }

  @Test
  fun `updateTypeSuggestions normalizes category names - Clothes`() {
    val context = ApplicationProvider.getApplicationContext<Context>()
    viewModel.initTypeSuggestions(context)

    viewModel.setCategory("Clothes")
    viewModel.updateTypeSuggestions("")

    val state = viewModel.uiState.value
    assertTrue(state.suggestions.isNotEmpty())
  }

  @Test
  fun `updateTypeSuggestions normalizes category names - clothing`() {
    val context = ApplicationProvider.getApplicationContext<Context>()
    viewModel.initTypeSuggestions(context)

    viewModel.setCategory("clothing")
    viewModel.updateTypeSuggestions("")

    val state = viewModel.uiState.value
    assertTrue(state.suggestions.isNotEmpty())
  }

  @Test
  fun `updateTypeSuggestions normalizes category names - Shoes`() {
    val context = ApplicationProvider.getApplicationContext<Context>()
    viewModel.initTypeSuggestions(context)

    viewModel.setCategory("Shoes")
    viewModel.updateTypeSuggestions("")

    val state = viewModel.uiState.value
    assertTrue(state.suggestions.isNotEmpty())
  }

  @Test
  fun `updateTypeSuggestions normalizes category names - shoe`() {
    val context = ApplicationProvider.getApplicationContext<Context>()
    viewModel.initTypeSuggestions(context)

    viewModel.setCategory("shoe")
    viewModel.updateTypeSuggestions("")

    val state = viewModel.uiState.value
    assertTrue(state.suggestions.isNotEmpty())
  }

  @Test
  fun `updateTypeSuggestions normalizes category names - Bags`() {
    val context = ApplicationProvider.getApplicationContext<Context>()
    viewModel.initTypeSuggestions(context)

    viewModel.setCategory("Bags")
    viewModel.updateTypeSuggestions("")

    val state = viewModel.uiState.value
    assertTrue(state.suggestions.isNotEmpty())
  }

  @Test
  fun `updateTypeSuggestions normalizes category names - bag`() {
    val context = ApplicationProvider.getApplicationContext<Context>()
    viewModel.initTypeSuggestions(context)

    viewModel.setCategory("bag")
    viewModel.updateTypeSuggestions("")

    val state = viewModel.uiState.value
    assertTrue(state.suggestions.isNotEmpty())
  }

  @Test
  fun `updateTypeSuggestions normalizes category names - Accessories`() {
    val context = ApplicationProvider.getApplicationContext<Context>()
    viewModel.initTypeSuggestions(context)

    viewModel.setCategory("Accessories")
    viewModel.updateTypeSuggestions("")

    val state = viewModel.uiState.value
    assertTrue(state.suggestions.isNotEmpty())
  }

  @Test
  fun `updateTypeSuggestions normalizes category names - accessory`() {
    val context = ApplicationProvider.getApplicationContext<Context>()
    viewModel.initTypeSuggestions(context)

    viewModel.setCategory("accessory")
    viewModel.updateTypeSuggestions("")

    val state = viewModel.uiState.value
    assertTrue(state.suggestions.isNotEmpty())
  }

  @Test
  fun `updateTypeSuggestions returns empty list for invalid category`() {
    val context = ApplicationProvider.getApplicationContext<Context>()
    viewModel.initTypeSuggestions(context)

    viewModel.setCategory("InvalidCategory")
    viewModel.updateTypeSuggestions("")

    val state = viewModel.uiState.value
    assertTrue(state.suggestions.isEmpty())
  }

  @Test
  fun `updateTypeSuggestions filters case insensitive`() {
    val context = ApplicationProvider.getApplicationContext<Context>()
    viewModel.initTypeSuggestions(context)

    viewModel.setCategory("Clothing")
    viewModel.updateTypeSuggestions("t-shirt")

    val state = viewModel.uiState.value
    assertTrue(state.suggestions.any { it.equals("T-shirt", ignoreCase = true) })
  }
}
