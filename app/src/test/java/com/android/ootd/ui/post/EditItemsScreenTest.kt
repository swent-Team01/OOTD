package com.android.ootd.ui.post

import android.content.Context
import android.net.Uri
import androidx.compose.ui.test.assertHasClickAction
import androidx.compose.ui.test.assertIsDisplayed
import androidx.compose.ui.test.assertIsEnabled
import androidx.compose.ui.test.assertIsNotDisplayed
import androidx.compose.ui.test.assertIsNotEnabled
import androidx.compose.ui.test.assertTextContains
import androidx.compose.ui.test.junit4.createComposeRule
import androidx.compose.ui.test.onNodeWithContentDescription
import androidx.compose.ui.test.onNodeWithTag
import androidx.compose.ui.test.onNodeWithText
import androidx.compose.ui.test.performClick
import androidx.compose.ui.test.performTextInput
import androidx.test.core.app.ApplicationProvider
import com.android.ootd.model.account.AccountRepository
import com.android.ootd.model.items.ImageData
import com.android.ootd.model.items.Item
import com.android.ootd.model.items.ItemsRepository
import com.android.ootd.model.items.Material
import com.android.ootd.ui.post.items.EditItemsScreen
import com.android.ootd.ui.post.items.EditItemsScreenSmallPreview
import com.android.ootd.ui.post.items.EditItemsScreenTestTags
import com.android.ootd.ui.post.items.EditItemsViewModel
import io.mockk.every
import io.mockk.mockk
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith
import org.robolectric.RobolectricTestRunner

// Test partially generated by the AI coding agent: Claude Sonnet 4.5
@RunWith(RobolectricTestRunner::class)
class EditItemsScreenTest {

  @get:Rule val composeTestRule = createComposeRule()

  private lateinit var mockViewModel: EditItemsViewModel
  private lateinit var mockRepository: ItemsRepository
  private lateinit var mockAccountRepository: AccountRepository
  private lateinit var context: Context

  private fun ensureAdditionalDetailsVisible() {
    val alreadyVisible =
        runCatching {
              composeTestRule
                  .onNodeWithTag(
                      EditItemsScreenTestTags.INPUT_ITEM_MATERIAL, useUnmergedTree = true)
                  .assertExists()
            }
            .isSuccess
    if (!alreadyVisible) {
      composeTestRule
          .onNodeWithTag(EditItemsScreenTestTags.ADDITIONAL_DETAILS_TOGGLE)
          .performClick()
      composeTestRule.waitForIdle()
    }
  }

  @Before
  fun setup() {
    context = ApplicationProvider.getApplicationContext()
    mockRepository = mockk(relaxed = true)
    mockAccountRepository = mockk(relaxed = true)
    mockViewModel = EditItemsViewModel(mockRepository, mockAccountRepository)
  }

  @Test
  fun `screen displays all UI components`() {
    composeTestRule.setContent { EditItemsScreen(editItemsViewModel = mockViewModel) }

    composeTestRule.onNodeWithText("EDIT ITEMS").assertIsDisplayed()
    composeTestRule.onNodeWithTag(EditItemsScreenTestTags.PLACEHOLDER_PICTURE).assertIsDisplayed()
    composeTestRule.onNodeWithTag(EditItemsScreenTestTags.INPUT_ADD_PICTURE_GALLERY).assertExists()
    composeTestRule.onNodeWithTag(EditItemsScreenTestTags.INPUT_ADD_PICTURE_CAMERA).assertExists()
    composeTestRule.onNodeWithTag(EditItemsScreenTestTags.INPUT_ITEM_CATEGORY).assertExists()
    composeTestRule.onNodeWithTag(EditItemsScreenTestTags.INPUT_ITEM_TYPE).assertExists()
    composeTestRule.onNodeWithTag(EditItemsScreenTestTags.INPUT_ITEM_BRAND).assertExists()
    composeTestRule.onNodeWithTag(EditItemsScreenTestTags.INPUT_ITEM_PRICE).assertExists()
    ensureAdditionalDetailsVisible()
    composeTestRule.onNodeWithTag(EditItemsScreenTestTags.ADDITIONAL_DETAILS_TOGGLE).assertExists()
    composeTestRule.onNodeWithTag(EditItemsScreenTestTags.ADDITIONAL_DETAILS_TOGGLE).performClick()
    composeTestRule.waitForIdle()
    composeTestRule.onNodeWithTag(EditItemsScreenTestTags.ADDITIONAL_DETAILS_TOGGLE).assertExists()
    composeTestRule.onNodeWithTag(EditItemsScreenTestTags.INPUT_ITEM_LINK).assertExists()
    composeTestRule.onNodeWithTag(EditItemsScreenTestTags.BUTTON_SAVE_CHANGES).assertExists()
    composeTestRule.onNodeWithTag(EditItemsScreenTestTags.BUTTON_DELETE_ITEM).assertExists()
  }

  @Test
  fun `edit preview keeps additional details collapsed by default`() {
    composeTestRule.setContent { EditItemsScreenSmallPreview() }

    composeTestRule.onNodeWithTag(EditItemsScreenTestTags.ADDITIONAL_DETAILS_TOGGLE).assertExists()
    composeTestRule
        .onNodeWithTag(EditItemsScreenTestTags.ADDITIONAL_DETAILS_SECTION, useUnmergedTree = true)
        .assertIsNotDisplayed()
  }

  @Test
  fun `gallery button is clickable`() {
    composeTestRule.setContent { EditItemsScreen(editItemsViewModel = mockViewModel) }

    composeTestRule
        .onNodeWithTag(EditItemsScreenTestTags.INPUT_ADD_PICTURE_GALLERY)
        .assertHasClickAction()
        .assertIsDisplayed()
  }

  @Test
  fun `camera button is clickable`() {
    composeTestRule.setContent { EditItemsScreen(editItemsViewModel = mockViewModel) }

    composeTestRule
        .onNodeWithTag(EditItemsScreenTestTags.INPUT_ADD_PICTURE_CAMERA)
        .assertHasClickAction()
        .assertIsDisplayed()
  }

  @Test
  fun `save button is disabled when required fields are empty`() {
    composeTestRule.setContent { EditItemsScreen(editItemsViewModel = mockViewModel) }

    composeTestRule.onNodeWithTag(EditItemsScreenTestTags.BUTTON_SAVE_CHANGES).assertIsNotEnabled()
  }

  @Test
  fun `save button is enabled when required fields are filled`() {
    val mockUri = mockk<Uri>()
    every { mockUri.toString() } returns "content://test"

    mockViewModel.setPhoto(mockUri)
    mockViewModel.setCategory("Clothing")

    composeTestRule.setContent { EditItemsScreen(editItemsViewModel = mockViewModel) }

    composeTestRule.onNodeWithTag(EditItemsScreenTestTags.BUTTON_SAVE_CHANGES).assertIsEnabled()
  }

  @Test
  fun `delete button is disabled when itemId is empty`() {
    composeTestRule.setContent { EditItemsScreen(editItemsViewModel = mockViewModel) }

    composeTestRule.onNodeWithTag(EditItemsScreenTestTags.BUTTON_DELETE_ITEM).assertIsNotEnabled()
  }

  @Test
  fun `delete button is enabled when itemId is not empty`() {
    mockViewModel.loadItem(
        Item(
            itemUuid = "test-id",
            postUuids = listOf("test_post_uuid"),
            image = ImageData("test-image-id", "https://example.com/test.jpg"),
            category = "Clothing",
            type = null,
            brand = null,
            price = null,
            material = emptyList(),
            link = null,
            ownerId = "ownerID"))

    composeTestRule.setContent { EditItemsScreen(editItemsViewModel = mockViewModel) }

    composeTestRule.onNodeWithTag(EditItemsScreenTestTags.BUTTON_DELETE_ITEM).assertIsEnabled()
  }

  @Test
  fun `category dropdown shows and selects option`() {
    composeTestRule.setContent { EditItemsScreen(editItemsViewModel = mockViewModel) }

    // Click to open dropdown
    composeTestRule.onNodeWithTag(EditItemsScreenTestTags.INPUT_ITEM_CATEGORY).performClick()

    // Select an option
    composeTestRule.onNodeWithText("Clothing").performClick()

    // Verify selection
    composeTestRule
        .onNodeWithTag(EditItemsScreenTestTags.INPUT_ITEM_CATEGORY)
        .assertTextContains("Clothing")
  }

  @Test
  fun `type field accepts text input`() {
    composeTestRule.setContent { EditItemsScreen(editItemsViewModel = mockViewModel) }

    composeTestRule
        .onNodeWithTag(EditItemsScreenTestTags.INPUT_ITEM_TYPE)
        .performTextInput("T-shirt")

    composeTestRule
        .onNodeWithTag(EditItemsScreenTestTags.INPUT_ITEM_TYPE)
        .assertTextContains("T-shirt")
  }

  @Test
  fun `brand field accepts text input`() {
    composeTestRule.setContent { EditItemsScreen(editItemsViewModel = mockViewModel) }

    composeTestRule.onNodeWithTag(EditItemsScreenTestTags.INPUT_ITEM_BRAND).performTextInput("Nike")

    composeTestRule
        .onNodeWithTag(EditItemsScreenTestTags.INPUT_ITEM_BRAND)
        .assertTextContains("Nike")
  }

  @Test
  fun `price field accepts numeric input`() {
    composeTestRule.setContent { EditItemsScreen(editItemsViewModel = mockViewModel) }

    composeTestRule
        .onNodeWithTag(EditItemsScreenTestTags.INPUT_ITEM_PRICE)
        .performTextInput("49.99")

    composeTestRule
        .onNodeWithTag(EditItemsScreenTestTags.INPUT_ITEM_PRICE)
        .assertTextContains("49.99")
  }

  @Test
  fun `link field accepts text input`() {
    composeTestRule.setContent { EditItemsScreen(editItemsViewModel = mockViewModel) }

    composeTestRule
        .onNodeWithTag(EditItemsScreenTestTags.INPUT_ITEM_LINK, useUnmergedTree = true)
        .performTextInput("https://example.com")

    composeTestRule
        .onNodeWithTag(EditItemsScreenTestTags.INPUT_ITEM_LINK, useUnmergedTree = true)
        .assertTextContains("https://example.com")
  }

  @Test
  fun `material field accepts text input`() {
    mockViewModel.setMaterial("Cotton 80%, Wool 20%")
    assert(mockViewModel.uiState.value.materialText == "Cotton 80%, Wool 20%")
    assert(mockViewModel.uiState.value.material.size == 2)
  }

  @Test
  fun `screen loads item data correctly`() {
    val item =
        Item(
            itemUuid = "test-id",
            postUuids = listOf("test_post_uuid"),
            image = ImageData("test-image-id", "https://example.com/test.jpg"),
            category = "Clothing",
            type = "T-shirt",
            brand = "Nike",
            price = 49.99,
            material = listOf(Material("Cotton", 100.0)),
            link = "https://example.com",
            ownerId = "ownerId")

    mockViewModel.loadItem(item)

    composeTestRule.setContent { EditItemsScreen(editItemsViewModel = mockViewModel) }

    composeTestRule
        .onNodeWithTag(EditItemsScreenTestTags.INPUT_ITEM_CATEGORY)
        .assertTextContains("Clothing")
    composeTestRule
        .onNodeWithTag(EditItemsScreenTestTags.INPUT_ITEM_TYPE)
        .assertTextContains("T-shirt")
    composeTestRule
        .onNodeWithTag(EditItemsScreenTestTags.INPUT_ITEM_BRAND)
        .assertTextContains("Nike")
    composeTestRule
        .onNodeWithTag(EditItemsScreenTestTags.INPUT_ITEM_PRICE)
        .assertTextContains("49.99")
    composeTestRule.onNodeWithTag(EditItemsScreenTestTags.ADDITIONAL_DETAILS_TOGGLE).performClick()
    composeTestRule.waitForIdle()
    composeTestRule
        .onNodeWithTag(EditItemsScreenTestTags.INPUT_ITEM_LINK, useUnmergedTree = true)
        .assertTextContains("https://example.com")
  }

  @Test
  fun `goBack is called when back button is clicked`() {
    var backCalled = false
    composeTestRule.setContent {
      EditItemsScreen(editItemsViewModel = mockViewModel, goBack = { backCalled = true })
    }

    composeTestRule.onNodeWithContentDescription("Back").performClick()

    assert(backCalled)
  }

  @Test
  fun `placeholder is shown when no image is selected`() {
    composeTestRule.setContent { EditItemsScreen(editItemsViewModel = mockViewModel) }

    composeTestRule.onNodeWithText("No picture yet").assertIsDisplayed()
  }

  @Test
  fun `all input fields have proper labels`() {
    composeTestRule.setContent { EditItemsScreen(editItemsViewModel = mockViewModel) }

    // Category is now a dropdown, so check it exists with different assertion
    composeTestRule.onNodeWithTag(EditItemsScreenTestTags.INPUT_ITEM_CATEGORY).assertExists()
    composeTestRule.onNodeWithText("Type").assertExists()
    composeTestRule.onNodeWithText("Brand").assertExists()
    composeTestRule.onNodeWithText("Item price").assertExists()
    composeTestRule.onNodeWithText("Link").assertExists()
  }

  @Test
  fun `buttons have proper text labels`() {
    composeTestRule.setContent { EditItemsScreen(editItemsViewModel = mockViewModel) }

    composeTestRule.onNodeWithText("Select from Gallery").assertExists()
    composeTestRule.onNodeWithText("Take a new picture").assertExists()
    composeTestRule.onNodeWithText("Save Changes").assertExists()
    composeTestRule.onNodeWithText("Delete Item").assertExists()
  }
}
