package com.android.ootd.ui.feed

import com.android.ootd.model.account.AccountRepository
import com.android.ootd.model.authentication.AccountService
import com.android.ootd.model.feed.FeedRepository
import com.android.ootd.model.items.ImageData
import com.android.ootd.model.items.Item
import com.android.ootd.model.items.ItemsRepository
import com.android.ootd.model.posts.OutfitPost
import io.mockk.coEvery
import io.mockk.coVerify
import io.mockk.every
import io.mockk.mockk
import io.mockk.unmockkAll
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.StandardTestDispatcher
import kotlinx.coroutines.test.advanceUntilIdle
import kotlinx.coroutines.test.resetMain
import kotlinx.coroutines.test.runTest
import kotlinx.coroutines.test.setMain
import org.junit.After
import org.junit.Assert.assertEquals
import org.junit.Assert.assertFalse
import org.junit.Assert.assertNotNull
import org.junit.Assert.assertNull
import org.junit.Assert.assertTrue
import org.junit.Before
import org.junit.Test

/**
 * Unit tests for [SeeFitViewModel].
 *
 * These tests use mocking to isolate the ViewModel from the repository layer. DISCLAIMER: These
 * tests were partly generated by AI and verified by humans.
 */
@OptIn(ExperimentalCoroutinesApi::class)
class SeeFitViewModelTest {

  private lateinit var viewModel: SeeFitViewModel
  private lateinit var mockItemsRepository: ItemsRepository
  private lateinit var mockFeedRepository: FeedRepository

  private lateinit var mockAccountService: AccountService
  private lateinit var mockAccountRepository: AccountRepository
  private val testDispatcher = StandardTestDispatcher()

  private val testItem1 =
      Item(
          itemUuid = "item1",
          postUuids = listOf("post1"),
          image = ImageData("img1", "https://example.com/img1.jpg"),
          category = "Clothing",
          type = "T-Shirt",
          brand = "Nike",
          price = 29.99,
          material = emptyList(),
          link = "https://example.com/tshirt",
          ownerId = "owner1")

  private val testItem2 =
      Item(
          itemUuid = "item2",
          postUuids = listOf("post1", "post2"),
          image = ImageData("img2", "https://example.com/img2.jpg"),
          category = "Shoes",
          type = "Sneakers",
          brand = "Adidas",
          price = 89.99,
          material = emptyList(),
          link = "https://example.com/sneakers",
          ownerId = "owner1")

  private val testPost1 =
      OutfitPost(
          postUID = "post1",
          name = "Test User",
          ownerId = "owner1",
          userProfilePicURL = "https://example.com/profile.jpg",
          outfitURL = "https://example.com/outfit.jpg",
          description = "Test outfit",
          itemsID = listOf("item1", "item2"),
          timestamp = System.currentTimeMillis())

  private val testPost2 =
      OutfitPost(
          postUID = "post2",
          name = "Another User",
          ownerId = "owner2",
          userProfilePicURL = "https://example.com/profile2.jpg",
          outfitURL = "https://example.com/outfit2.jpg",
          description = "Another outfit",
          itemsID = listOf("item2"),
          timestamp = System.currentTimeMillis())

  @Before
  fun setup() {
    Dispatchers.setMain(testDispatcher)
    mockItemsRepository = mockk(relaxed = true)
    mockFeedRepository = mockk(relaxed = true)
    mockAccountService = mockk(relaxed = true)
    mockAccountRepository = mockk(relaxed = true)
    every { mockAccountService.currentUserId } returns "user-1"
    viewModel =
        SeeFitViewModel(
            itemsRepository = mockItemsRepository,
            feedRepository = mockFeedRepository,
            accountService = mockAccountService,
            accountRepository = mockAccountRepository)
  }

  @After
  fun tearDown() {
    Dispatchers.resetMain()
    unmockkAll()
  }

  // ========================================================================
  // Initial State Tests
  // ========================================================================

  @Test
  fun `initial state has empty items and no loading`() {
    val state = viewModel.uiState.value

    assertTrue(state.items.isEmpty())
    assertFalse(state.isLoading)
    assertNull(state.errorMessage)
  }

  // ========================================================================
  // getItemsForPost Tests
  // ========================================================================

  @Test
  fun `getItemsForPost with empty postUuid does not fetch items`() = runTest {
    viewModel.getItemsForPost("")

    advanceUntilIdle()

    coVerify(exactly = 0) { mockFeedRepository.getPostById(any()) }
    coVerify(exactly = 0) { mockItemsRepository.getFriendItemsForPost(any(), any()) }

    val state = viewModel.uiState.value
    assertTrue(state.items.isEmpty())
    assertFalse(state.isLoading)
    assertNotNull(state.errorMessage)
  }

  @Test
  fun `getItemsForPost sets isLoading to true during fetch`() = runTest {
    coEvery { mockFeedRepository.getPostById("post1") } returns testPost1
    coEvery { mockItemsRepository.getFriendItemsForPost("post1", "owner1") } coAnswers
        {
          // Simulate delay
          kotlinx.coroutines.delay(100)
          listOf(testItem1, testItem2)
        }

    viewModel.getItemsForPost("post1")

    // After launching but before completion
    testDispatcher.scheduler.advanceTimeBy(50)
    assertTrue(viewModel.uiState.value.isLoading)

    advanceUntilIdle()
  }

  @Test
  fun `getItemsForPost successfully loads items`() = runTest {
    val expectedItems = listOf(testItem1, testItem2)
    // Mock both cached and fresh fetch to return the same data
    coEvery { mockFeedRepository.getPostById("post1") } returns testPost1
    coEvery { mockItemsRepository.getFriendItemsForPost("post1", "owner1") } returns expectedItems

    viewModel.getItemsForPost("post1")

    // Advance past the 2-second timeout to ensure fresh fetch completes
    testDispatcher.scheduler.advanceTimeBy(2100)
    advanceUntilIdle()

    val state = viewModel.uiState.value
    assertEquals(expectedItems, state.items)
    assertFalse(state.isLoading)
    assertNull(state.errorMessage)

    // Should be called twice: once for cached, once for fresh
    coVerify(atLeast = 1) { mockFeedRepository.getPostById("post1") }
    coVerify(atLeast = 1) { mockItemsRepository.getFriendItemsForPost("post1", "owner1") }
  }

  @Test
  fun `getItemsForPost with different postUuids fetches correct items`() = runTest {
    val items1 = listOf(testItem1)
    val items2 = listOf(testItem2)

    coEvery { mockFeedRepository.getPostById("post1") } returns testPost1
    coEvery { mockFeedRepository.getPostById("post2") } returns testPost2
    coEvery { mockItemsRepository.getFriendItemsForPost("post1", "owner1") } returns items1
    coEvery { mockItemsRepository.getFriendItemsForPost("post2", "owner2") } returns items2

    // Fetch first post
    viewModel.getItemsForPost("post1")
    testDispatcher.scheduler.advanceTimeBy(2100)
    advanceUntilIdle()
    assertEquals(items1, viewModel.uiState.value.items)

    // Fetch second post
    viewModel.getItemsForPost("post2")
    testDispatcher.scheduler.advanceTimeBy(2100)
    advanceUntilIdle()
    assertEquals(items2, viewModel.uiState.value.items)

    coVerify(atLeast = 1) { mockFeedRepository.getPostById("post1") }
    coVerify(atLeast = 1) { mockFeedRepository.getPostById("post2") }
    coVerify(atLeast = 1) { mockItemsRepository.getFriendItemsForPost("post1", "owner1") }
    coVerify(atLeast = 1) { mockItemsRepository.getFriendItemsForPost("post2", "owner2") }
  }

  @Test
  fun `getItemsForPost with empty result returns empty list`() = runTest {
    coEvery { mockFeedRepository.getPostById("post-no-items") } returns
        testPost1.copy(postUID = "post-no-items")
    coEvery { mockItemsRepository.getFriendItemsForPost("post-no-items", "owner1") } returns
        emptyList()

    viewModel.getItemsForPost("post-no-items")

    advanceUntilIdle()

    val state = viewModel.uiState.value
    assertTrue(state.items.isEmpty())
    assertFalse(state.isLoading)
    assertNull(state.errorMessage)
  }

  @Test
  fun `getItemsForPost handles feedRepository exception`() = runTest {
    val errorMessage = "Post not found"
    coEvery { mockFeedRepository.getPostById("post1") } throws Exception(errorMessage)

    viewModel.getItemsForPost("post1")

    advanceUntilIdle()

    val state = viewModel.uiState.value
    assertTrue(state.items.isEmpty())
    assertFalse(state.isLoading)
    assertNotNull(state.errorMessage)
  }

  @Test
  fun `getItemsForPost handles itemsRepository exception`() = runTest {
    val errorMessage = "Network error"
    // Mock post to succeed but items fetch to fail
    coEvery { mockFeedRepository.getPostById("post1") } returns testPost1
    coEvery { mockItemsRepository.getFriendItemsForPost("post1", "owner1") } throws
        Exception(errorMessage)

    viewModel.getItemsForPost("post1")

    testDispatcher.scheduler.advanceTimeBy(2100)
    advanceUntilIdle()

    val state = viewModel.uiState.value
    // With the new implementation, exceptions in items fetch are caught
    // and result in empty items, not an error message
    assertTrue(state.items.isEmpty())
    assertFalse(state.isLoading)
    // The error is swallowed, so no error message is set
    assertNull(state.errorMessage)
  }

  @Test
  fun `getItemsForPost clears previous error message on new fetch`() = runTest {
    // First fetch fails - set error manually since exceptions are caught
    viewModel.setErrorMessage("Previous error")

    assertTrue(viewModel.uiState.value.errorMessage != null)

    // Second fetch succeeds
    coEvery { mockFeedRepository.getPostById("post2") } returns testPost2
    coEvery { mockItemsRepository.getFriendItemsForPost("post2", "owner2") } returns
        listOf(testItem2)

    viewModel.getItemsForPost("post2")
    testDispatcher.scheduler.advanceTimeBy(2100)
    advanceUntilIdle()

    val state = viewModel.uiState.value
    assertNull(state.errorMessage)
    assertEquals(1, state.items.size)
  }

  // ========================================================================
  // clearMessage Tests
  // ========================================================================

  @Test
  fun `clearMessage removes error message`() = runTest {
    // Set an error
    coEvery { mockFeedRepository.getPostById("post1") } throws Exception("Test error")

    viewModel.getItemsForPost("post1")
    advanceUntilIdle()

    assertTrue(viewModel.uiState.value.errorMessage != null)

    // Clear the message
    viewModel.clearMessage()

    assertNull(viewModel.uiState.value.errorMessage)
  }

  @Test
  fun `refreshStarredItems updates state`() = runTest {
    coEvery { mockAccountRepository.getStarredItems("user-1") } returns listOf("item1", "item2")

    viewModel.refreshStarredItems()

    advanceUntilIdle()

    assertEquals(setOf("item1", "item2"), viewModel.uiState.value.starredItemIds)
  }

  @Test
  fun `toggleStar updates starred ids`() = runTest {
    coEvery { mockAccountRepository.toggleStarredItem("item1") } returns listOf("item1")

    viewModel.toggleStar(testItem1)

    advanceUntilIdle()

    assertTrue(viewModel.uiState.value.starredItemIds.contains("item1"))
  }

  @Test
  fun `toggleStar surfaces error message when repository fails`() = runTest {
    coEvery { mockAccountRepository.toggleStarredItem("item1") } throws Exception("boom")

    viewModel.toggleStar(testItem1)

    advanceUntilIdle()

    assertNotNull(viewModel.uiState.value.errorMessage)
  }

  @Test
  fun `toggleStar noops on blank item id`() = runTest {
    viewModel.toggleStar(testItem1.copy(itemUuid = ""))

    advanceUntilIdle()

    coVerify(exactly = 0) { mockAccountRepository.toggleStarredItem(any()) }
    assertTrue(viewModel.uiState.value.starredItemIds.isEmpty())
  }

  @Test
  fun `refreshStarredItems noops when user is blank`() = runTest {
    every { mockAccountService.currentUserId } returns ""

    viewModel.refreshStarredItems()
    advanceUntilIdle()

    coVerify(exactly = 0) { mockAccountRepository.getStarredItems(any()) }
    assertTrue(viewModel.uiState.value.starredItemIds.isEmpty())
  }
}
