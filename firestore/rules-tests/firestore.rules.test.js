import { describe, test, beforeAll, afterAll, expect } from 'vitest';
import { assertFails, assertSucceeds } from '@firebase/rules-unit-testing';
import { collection, deleteDoc, doc, getDoc, getDocs, query, setDoc, where } from 'firebase/firestore';
import { setup, setupFirestore } from './setup.js';

//Tests generated by AI but validated and fixed by human
describe('Firestore rules - OOTD friend-only feed', async () => {
  const env = await setup();

  const meCtx = env.authenticatedContext('me');
  const me = meCtx.firestore();

  const aliceCtx = env.authenticatedContext('u1');
  const alice = aliceCtx.firestore();

  beforeAll(async () => {
    await setupFirestore(env);
  });

  afterAll(async () => {
    await env.clearFirestore();
    await env.cleanup();
  });

  // /users rules
  test('User can read and write only their own /users/{uid} doc', async () => {
    await assertSucceeds(getDoc(doc(me, 'users/me')));
    await assertFails(getDoc(doc(me, 'users/u1')));

    // Use merge so we don't wipe the seeded friendUidSet that other tests depend on
    await assertSucceeds(
      setDoc(doc(me, 'users/me'), { uid: 'me', name: 'Me', friendList: [] }, { merge: true })
    );
    await assertFails(
      setDoc(doc(alice, 'users/me'), { uid: 'me' })
    );
  });

  // posts read rules
  test('Mutual friends can read each other posts; non-friends cannot', async () => {
    // me is mutual friends with u1 and u2 (seeded in setup), but not with u3/u9
    await assertSucceeds(getDoc(doc(me, 'posts/p1'))); // u1
    await assertSucceeds(getDoc(doc(me, 'posts/p2'))); // u2

    await assertFails(getDoc(doc(me, 'posts/p3'))); // u3 (one-way only)
    await assertFails(getDoc(doc(me, 'posts/p9'))); // u9 (non-friend)
  });

  test('Author can read their own post even without mutual friendship', async () => {
    const selfDb = env.authenticatedContext('me').firestore();
    await assertSucceeds(
      setDoc(doc(selfDb, 'posts/self_post'), {
        postUID: 'self_post', uid: 'me', name: 'Me', outfitURL: 'url', timestamp: Date.now()
      })
    );
    await assertSucceeds(getDoc(doc(selfDb, 'posts/self_post')));
  });

  test('List query: allowed when constrained to friends; denied when unfiltered', async () => {
    await assertSucceeds(
      getDocs(query(collection(me, 'posts'), where('uid', 'in', ['u1', 'u2'])))
    );

    await assertFails(getDocs(collection(me, 'posts')));
  });

  // posts write rules
  test('Author can create post only with own uid and matching postUID', async () => {
    await assertSucceeds(
      setDoc(doc(me, 'posts/post_me'), {
        postUID: 'post_me', uid: 'me', name: 'Me', outfitURL: 'url', timestamp: Date.now()
      })
    );

    // Mismatch between postUID and document id
    await assertFails(
      setDoc(doc(me, 'posts/post_wrong'), {
        postUID: 'post_me', uid: 'me', name: 'Me', outfitURL: 'url', timestamp: Date.now()
      })
    );

    // Missing required fields
    await assertFails(
      setDoc(doc(me, 'posts/post_missing'), { postUID: 'post_missing', uid: 'me' })
    );
  });

  test('Only author can update/delete; uid and postUID are immutable', async () => {
    // Seed a post by me
    await assertSucceeds(
      setDoc(doc(me, 'posts/post_edit'), {
        postUID: 'post_edit', uid: 'me', name: 'Me', outfitURL: 'url', timestamp: 1
      })
    );

    // Author can update non-identity fields
    await assertSucceeds(
      setDoc(doc(me, 'posts/post_edit'), {
        postUID: 'post_edit', uid: 'me', name: 'Me', outfitURL: 'url2', timestamp: 2
      })
    );

    // Cannot change postUID or uid
    await assertFails(
      setDoc(doc(me, 'posts/post_edit'), {
        postUID: 'changed', uid: 'me', name: 'Me', outfitURL: 'url2', timestamp: 3
      })
    );
    await assertFails(
      setDoc(doc(me, 'posts/post_edit'), {
        postUID: 'post_edit', uid: 'someoneElse', name: 'Me', outfitURL: 'url2', timestamp: 3
      })
    );

    // Non-author cannot update or delete
    await assertFails(
      setDoc(doc(alice, 'posts/post_edit'), {
        postUID: 'post_edit', uid: 'me', name: 'Me', outfitURL: 'url3', timestamp: 4
      })
    );
    await assertFails(deleteDoc(doc(alice, 'posts/post_edit')));

    // Author can delete
    await assertSucceeds(deleteDoc(doc(me, 'posts/post_edit')));
  });
});
